/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AuthRequestDTO
 */
export interface AuthRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AuthRequestDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequestDTO
     */
    password: string;
}
/**
 * 
 * @export
 * @interface BaseAlgorithmPredictInput
 */
export interface BaseAlgorithmPredictInput {
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmPredictInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    modelName?: string;
    /**
     * 
     * @type {DataProvider}
     * @memberof BaseAlgorithmPredictInput
     */
    dataProvider?: DataProvider;
    /**
     * 
     * @type {DataInputOption}
     * @memberof BaseAlgorithmPredictInput
     */
    dataInputOption?: DataInputOption;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    listFieldsForPredict?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    dbDocIds?: Array<string>;
    /**
     * 
     * @type {FileInput}
     * @memberof BaseAlgorithmPredictInput
     */
    fileInput?: FileInput;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmPredictInput
     */
    threshold?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmPredictInput
     */
    dimensionalityReduction?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    dataType?: string;
}
/**
 * 
 * @export
 * @interface BaseAlgorithmTrainInput
 */
export interface BaseAlgorithmTrainInput {
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmTrainInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    trainingESIndex?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    partType?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numClasses?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numTrees?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    featureSubsetStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    impurity?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxDepths?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxBins?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    bin?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmTrainInput
     */
    filterOutFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    modelName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmTrainInput
     */
    featuresSelectionEnableFlg?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    fraction?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxIter?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    layers?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    blockSize?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    lambda?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    regParam?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmTrainInput
     */
    intercept?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    elasticNetMixing?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof BaseAlgorithmTrainInput
     */
    dataForRetraining?: Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    lseed?: number;
}
/**
 * 
 * @export
 * @interface Board
 */
export interface Board {
    /**
     * 
     * @type {number}
     * @memberof Board
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Board
     */
    published?: boolean;
}
/**
 * 
 * @export
 * @interface ClassificationResponse
 */
export interface ClassificationResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof ClassificationResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof ClassificationResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ClassificationResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictedFeatureLine?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterResponse
 */
export interface ClusterResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof ClusterResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof ClusterResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof ClusterResponse
     */
    centers?: Array<Array<number>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ClusterResponse
     */
    totalPointsEachCluster?: { [key: string]: number; };
    /**
     * 
     * @type {Array<number>}
     * @memberof ClusterResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof ClusterResponse
     */
    actual?: Array<{ [key: string]: object; }>;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    processed?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterTrainInput
 */
export interface ClusterTrainInput {
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterTrainInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    trainingESIndex?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    partType?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numClasses?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numTrees?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    featureSubsetStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    impurity?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxDepths?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxBins?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    bin?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterTrainInput
     */
    filterOutFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    modelName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    featuresSelectionEnableFlg?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    fraction?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxIter?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    layers?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    blockSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    lambda?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    regParam?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    intercept?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    elasticNetMixing?: number;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ClusterTrainInput
     */
    dataForRetraining?: Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numClusters?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numIterations?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numEstimators?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxFeatures?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxSamples?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    lseed?: number;
}
/**
 * 
 * @export
 * @interface Cmncd
 */
export interface Cmncd {
    /**
     * 
     * @type {number}
     * @memberof Cmncd
     */
    cmncdid?: number;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    _var?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    expln?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    usedvcd?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    groupcode?: string;
}
/**
 * 
 * @export
 * @interface Cmpntsrplc
 */
export interface Cmpntsrplc {
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    grid?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    stdval?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    prdval?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    nmval?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @interface CmpntsrplcData
 */
export interface CmpntsrplcData {
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    snsrnm?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    workr?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    rplcdate?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    expln?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    grid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcData
     */
    code?: string;
}
/**
 * 
 * @export
 * @interface CmpntsrplcHistry
 */
export interface CmpntsrplcHistry {
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcHistry
     */
    grid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcHistry
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcHistry
     */
    workr?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcHistry
     */
    rplcdate?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcHistry
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcHistry
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcHistry
     */
    mdfr?: string;
}
/**
 * 
 * @export
 * @interface CmpntsrplcInfo
 */
export interface CmpntsrplcInfo {
    /**
     * 
     * @type {number}
     * @memberof CmpntsrplcInfo
     */
    criid?: number;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    divs?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    brgd?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    bn?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    sdanm?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    sdatype?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    grid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    expln?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    stdvle?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    stdval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    prdvle?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    prdval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    nmvle?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    nmval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    dttime?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcInfo
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface CmpntsrplcResponse
 */
export interface CmpntsrplcResponse {
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    grid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    grnm?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    stdval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    prdval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    nmval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DataInputOption {
    File = 'INPUT_FROM_FILE',
    Es = 'INPUT_FROM_ES',
    Db = 'INPUT_FROM_DB'
}

/**
 * 
 * @export
 * @interface DataLookup
 */
export interface DataLookup {
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    lookupName?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    updatedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    delimiter?: string;
    /**
     * 
     * @type {number}
     * @memberof DataLookup
     */
    indexOfLabeledField?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DataProvider {
    Ktme = 'KTME',
    Globiz = 'GLOBIZ'
}

/**
 * 
 * @export
 * @interface DbDataUpdateInput
 */
export interface DbDataUpdateInput {
    /**
     * 
     * @type {number}
     * @memberof DbDataUpdateInput
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DbDataUpdateInput
     */
    partType?: string;
    /**
     * 
     * @type {number}
     * @memberof DbDataUpdateInput
     */
    aiPredict?: number;
    /**
     * 
     * @type {string}
     * @memberof DbDataUpdateInput
     */
    aiAlgorithmName?: string;
    /**
     * 
     * @type {string}
     * @memberof DbDataUpdateInput
     */
    aiModelName?: string;
    /**
     * 
     * @type {string}
     * @memberof DbDataUpdateInput
     */
    aiPredictDate?: string;
}
/**
 * 
 * @export
 * @interface DbJudgementUpdateInput
 */
export interface DbJudgementUpdateInput {
    /**
     * 
     * @type {number}
     * @memberof DbJudgementUpdateInput
     */
    idx?: number;
    /**
     * 
     * @type {number}
     * @memberof DbJudgementUpdateInput
     */
    userJudgement?: number;
}
/**
 * 
 * @export
 * @interface DbModelResponse
 */
export interface DbModelResponse {
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    algorithmResponseId?: number;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    partType?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    modelName?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    algorithmType?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DbModelResponse
     */
    checked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    trainingDataFileName?: string;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    fraction?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DbModelResponse
     */
    coefficients?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    rootMeanSquaredError?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    r2?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DbModelResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof DbModelResponse
     */
    residuals?: Array<object>;
}
/**
 * 
 * @export
 * @interface DriverAttitd
 */
export interface DriverAttitd {
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    daid?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    danm?: string;
    /**
     * 
     * @type {number}
     * @memberof DriverAttitd
     */
    bizlogic?: number;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    stdval?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    sign?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ERole {
    User = 'ROLE_USER',
    Moderator = 'ROLE_MODERATOR',
    Admin = 'ROLE_ADMIN'
}

/**
 * 
 * @export
 * @interface ExcelDownByMonitorDiagnos
 */
export interface ExcelDownByMonitorDiagnos {
    /**
     * 
     * @type {string}
     * @memberof ExcelDownByMonitorDiagnos
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof ExcelDownByMonitorDiagnos
     */
    part?: string;
    /**
     * 
     * @type {string}
     * @memberof ExcelDownByMonitorDiagnos
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ExcelDownByMonitorDiagnos
     */
    endDate?: string;
}
/**
 * 
 * @export
 * @interface FSResponse
 */
export interface FSResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof FSResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof FSResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    filteredFeatures?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    selectedFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    csv?: string;
    /**
     * 
     * @type {number}
     * @memberof FSResponse
     */
    numPrincipalComponents?: number;
}
/**
 * 
 * @export
 * @interface FileInput
 */
export interface FileInput {
    /**
     * 
     * @type {string}
     * @memberof FileInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInput
     */
    separator?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum HttpStatus {
    _100Continue = '100 CONTINUE',
    _101SwitchingProtocols = '101 SWITCHING_PROTOCOLS',
    _102Processing = '102 PROCESSING',
    _103Checkpoint = '103 CHECKPOINT',
    _200Ok = '200 OK',
    _201Created = '201 CREATED',
    _202Accepted = '202 ACCEPTED',
    _203NonAuthoritativeInformation = '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent = '204 NO_CONTENT',
    _205ResetContent = '205 RESET_CONTENT',
    _206PartialContent = '206 PARTIAL_CONTENT',
    _207MultiStatus = '207 MULTI_STATUS',
    _208AlreadyReported = '208 ALREADY_REPORTED',
    _226ImUsed = '226 IM_USED',
    _300MultipleChoices = '300 MULTIPLE_CHOICES',
    _301MovedPermanently = '301 MOVED_PERMANENTLY',
    _302Found = '302 FOUND',
    _302MovedTemporarily = '302 MOVED_TEMPORARILY',
    _303SeeOther = '303 SEE_OTHER',
    _304NotModified = '304 NOT_MODIFIED',
    _305UseProxy = '305 USE_PROXY',
    _307TemporaryRedirect = '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect = '308 PERMANENT_REDIRECT',
    _400BadRequest = '400 BAD_REQUEST',
    _401Unauthorized = '401 UNAUTHORIZED',
    _402PaymentRequired = '402 PAYMENT_REQUIRED',
    _403Forbidden = '403 FORBIDDEN',
    _404NotFound = '404 NOT_FOUND',
    _405MethodNotAllowed = '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable = '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired = '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout = '408 REQUEST_TIMEOUT',
    _409Conflict = '409 CONFLICT',
    _410Gone = '410 GONE',
    _411LengthRequired = '411 LENGTH_REQUIRED',
    _412PreconditionFailed = '412 PRECONDITION_FAILED',
    _413PayloadTooLarge = '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge = '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong = '414 URI_TOO_LONG',
    _414RequestUriTooLong = '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType = '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable = '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed = '417 EXPECTATION_FAILED',
    _418IAmATeapot = '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource = '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure = '420 METHOD_FAILURE',
    _421DestinationLocked = '421 DESTINATION_LOCKED',
    _422UnprocessableEntity = '422 UNPROCESSABLE_ENTITY',
    _423Locked = '423 LOCKED',
    _424FailedDependency = '424 FAILED_DEPENDENCY',
    _425TooEarly = '425 TOO_EARLY',
    _426UpgradeRequired = '426 UPGRADE_REQUIRED',
    _428PreconditionRequired = '428 PRECONDITION_REQUIRED',
    _429TooManyRequests = '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge = '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons = '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError = '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented = '501 NOT_IMPLEMENTED',
    _502BadGateway = '502 BAD_GATEWAY',
    _503ServiceUnavailable = '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout = '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported = '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates = '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage = '507 INSUFFICIENT_STORAGE',
    _508LoopDetected = '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded = '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended = '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired = '511 NETWORK_AUTHENTICATION_REQUIRED'
}

/**
 * 
 * @export
 * @interface LifeThreshold
 */
export interface LifeThreshold {
    /**
     * 
     * @type {string}
     * @memberof LifeThreshold
     */
    snsrtype?: string;
    /**
     * 
     * @type {number}
     * @memberof LifeThreshold
     */
    distance?: number;
    /**
     * 
     * @type {number}
     * @memberof LifeThreshold
     */
    years?: number;
    /**
     * 
     * @type {string}
     * @memberof LifeThreshold
     */
    usedvcd?: string;
    /**
     * 
     * @type {string}
     * @memberof LifeThreshold
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof LifeThreshold
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof LifeThreshold
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof LifeThreshold
     */
    mdfr?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface Paramdesc
 */
export interface Paramdesc {
    /**
     * 
     * @type {string}
     * @memberof Paramdesc
     */
    detpartid?: string;
    /**
     * 
     * @type {string}
     * @memberof Paramdesc
     */
    detpart?: string;
    /**
     * 
     * @type {string}
     * @memberof Paramdesc
     */
    param?: string;
    /**
     * 
     * @type {string}
     * @memberof Paramdesc
     */
    desc?: string;
    /**
     * 
     * @type {string}
     * @memberof Paramdesc
     */
    faildesc?: string;
}
/**
 * 
 * @export
 * @interface ParamdescRequest
 */
export interface ParamdescRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ParamdescRequest
     */
    paramList?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ParamdescRequest
     */
    detpartid?: string;
}
/**
 * 
 * @export
 * @interface RandomForestClassificationResponse
 */
export interface RandomForestClassificationResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof RandomForestClassificationResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof RandomForestClassificationResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RandomForestClassificationResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictedFeatureLine?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    decisionTree?: string;
}
/**
 * 
 * @export
 * @interface ReTrainingInput
 */
export interface ReTrainingInput {
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof ReTrainingInput
     */
    newData?: Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {string}
     * @memberof ReTrainingInput
     */
    modelName?: string;
    /**
     * 
     * @type {string}
     * @memberof ReTrainingInput
     */
    partType?: string;
    /**
     * 
     * @type {string}
     * @memberof ReTrainingInput
     */
    algorithmName?: string;
}
/**
 * 
 * @export
 * @interface RegressionResponse
 */
export interface RegressionResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof RegressionResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof RegressionResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictedFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof RegressionResponse
     */
    coefficients?: Array<number>;
    /**
     * 
     * @type {Array<object>}
     * @memberof RegressionResponse
     */
    residuals?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof RegressionResponse
     */
    rootMeanSquaredError?: number;
    /**
     * 
     * @type {number}
     * @memberof RegressionResponse
     */
    r2?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ResponseStatus {
    None = 'NONE',
    Initialized = 'INITIALIZED',
    Success = 'SUCCESS',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ResponseType {
    Message = 'MESSAGE',
    ObjectData = 'OBJECT_DATA'
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    id?: number;
    /**
     * 
     * @type {ERole}
     * @memberof Role
     */
    name?: ERole;
}
/**
 * 
 * @export
 * @interface Sda
 */
export interface Sda {
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sdanm?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    divs?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    brgd?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    bn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    rgstno?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    mfdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    rgstdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    acqdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sdatype?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    divscode?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    brgdbncode?: string;
}
/**
 * 
 * @export
 * @interface SdaData
 */
export interface SdaData {
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    filenm?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    operdate?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    opertime?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    dttime?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engsta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    reqendtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engload?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    sdhspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    accpedal?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    cooltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    enggastemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engwarning?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engoilprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engoilsta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engheat?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    enggov?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    industfil?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    outtemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    cooloil?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    coollant?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fueltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transoutspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transinspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engoverctlmd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    overreqtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    autotrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    detailtrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    reqtrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    currttrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    emertransmd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transoiltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transoilheat?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fanmd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fanairtemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fancoolanttemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fanvvalduty?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    parksta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_break?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdbreak?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdcho?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    reqretdtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdoiltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    airmaster?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    breakoil?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    frtbreakprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    backbreakprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    airtankr?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    airtankl?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    frtairtand?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fuel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    voltage?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    battsta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    absoper?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    absyaji?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    abswarning?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2avgspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2lspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2rspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3lspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3rspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_1lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    dmotion?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_4lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    shiftmode?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowswitch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    norswitch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    highswitch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    pneumatic?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_8by8?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_6by6?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_1wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_4wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    promotewater?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lockrelease?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoilprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoiltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoilqty?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoilfilter?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    winchclutch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    backdooropen?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    overprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    overprseqp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    ctisairprs?: number;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    pbit?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    tableName?: string;
}
/**
 * 
 * @export
 * @interface SdaDataWithDtctsda
 */
export interface SdaDataWithDtctsda {
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    filenm?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    dttime?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    snsrvle?: string;
}
/**
 * 
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    divscode?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    brgdbncode?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    size?: number;
}
/**
 * 
 * @export
 * @interface SensorBearingLeftBallInterface
 */
export interface SensorBearingLeftBallInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_V_6912BSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    ai_LBSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_V_32922BSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    l_B_V_32924BSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftBallInterface
     */
    ai_LBSF_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftBallInterface
     */
    ai_LBSF_DATE?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftBallInterface
     */
    user_LBSF?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftBallInterface
     */
    user_LBSF_ID?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftBallInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftBallInterface
     */
    ai_LBSF_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftBallInterface
     */
    user_LBSF_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftBallInterface
     */
    sdaId?: string;
}
/**
 * 
 * @export
 * @interface SensorBearingLeftInsideInterface
 */
export interface SensorBearingLeftInsideInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    ai_LBPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_V_32922BPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_V_32924BPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    l_B_V_6912BPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftInsideInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftInsideInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftInsideInterface
     */
    user_LBPFI?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftInsideInterface
     */
    user_LBPFI_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftInsideInterface
     */
    ai_LBPFI_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftInsideInterface
     */
    ai_LBPFI_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftInsideInterface
     */
    ai_LBPFI_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftInsideInterface
     */
    user_LBPFI_ID?: string;
}
/**
 * 
 * @export
 * @interface SensorBearingLeftOutsideInterface
 */
export interface SensorBearingLeftOutsideInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    ai_LBPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_V_32922BPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_V_32924BPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    l_B_V_6912BPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftOutsideInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftOutsideInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftOutsideInterface
     */
    ai_LBPFO_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftOutsideInterface
     */
    ai_LBPFO_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftOutsideInterface
     */
    user_LBPFO_ID?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftOutsideInterface
     */
    ai_LBPFO_MODEL?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftOutsideInterface
     */
    user_LBPFO?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftOutsideInterface
     */
    user_LBPFO_DATE?: string;
}
/**
 * 
 * @export
 * @interface SensorBearingLeftRetainerInterface
 */
export interface SensorBearingLeftRetainerInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_V_32922FTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    ai_LFTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_V_32924FTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_V_6912FTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    l_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftRetainerInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftRetainerInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingLeftRetainerInterface
     */
    user_LFTF?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftRetainerInterface
     */
    user_LFTF_ID?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftRetainerInterface
     */
    user_LFTF_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftRetainerInterface
     */
    ai_LFTF_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftRetainerInterface
     */
    ai_LFTF_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingLeftRetainerInterface
     */
    ai_LFTF_DATE?: string;
}
/**
 * 
 * @export
 * @interface SensorBearingRightBallInterface
 */
export interface SensorBearingRightBallInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_V_32924BSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_V_32922BSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_V_6912BSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    ai_RBSF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    r_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightBallInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightBallInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightBallInterface
     */
    user_RBSF?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightBallInterface
     */
    ai_RBSF_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightBallInterface
     */
    ai_RBSF_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightBallInterface
     */
    user_RBSF_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightBallInterface
     */
    ai_RBSF_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightBallInterface
     */
    user_RBPFO_ID?: string;
}
/**
 * 
 * @export
 * @interface SensorBearingRightInsideInterface
 */
export interface SensorBearingRightInsideInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    ai_RBPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_V_6912BPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_V_32922BPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    r_B_V_32924BPFI?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightInsideInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightInsideInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightInsideInterface
     */
    ai_RBPFI_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightInsideInterface
     */
    user_RBPFI_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightInsideInterface
     */
    ai_RBPFI_DATE?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightInsideInterface
     */
    user_RBPFI?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightInsideInterface
     */
    ai_RBPFI_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightInsideInterface
     */
    user_RBPFI_ID?: string;
}
/**
 * 
 * @export
 * @interface SensorBearingRightOutsideInterface
 */
export interface SensorBearingRightOutsideInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    ai_RBPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_V_6912BPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_V_32924BPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_V_32922BPFO?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    r_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightOutsideInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightOutsideInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightOutsideInterface
     */
    ai_RBPFO_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightOutsideInterface
     */
    ai_RBPFO_DATE?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightOutsideInterface
     */
    user_RBPFO?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightOutsideInterface
     */
    ai_RBPFO_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightOutsideInterface
     */
    user_RBPFO_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightOutsideInterface
     */
    user_RBPFO_ID?: string;
}
/**
 * 
 * @export
 * @interface SensorBearingRightRetainerInterface
 */
export interface SensorBearingRightRetainerInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_V_Demodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_T_Temperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_V_32924FTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_V_32922FTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_S_Fault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_S_Fault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    r_B_V_6912FTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    ai_RFTF?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightRetainerInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightRetainerInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearingRightRetainerInterface
     */
    user_RFTF?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightRetainerInterface
     */
    ai_RFTF_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightRetainerInterface
     */
    ai_RFTF_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightRetainerInterface
     */
    user_RFTF_ID?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightRetainerInterface
     */
    user_RFTF_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearingRightRetainerInterface
     */
    ai_RFTF_DATE?: string;
}
/**
 * 
 * @export
 * @interface SensorEngineInterface
 */
export interface SensorEngineInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    e_V_1_2X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    e_V_1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    ai_ENGINE?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    e_V_OverallRMS?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    e_V_Crestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorEngineInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngineInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorEngineInterface
     */
    user_ENGINE?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorEngineInterface
     */
    ai_ENGINE_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngineInterface
     */
    ai_ENGINE_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngineInterface
     */
    user_ENGINE_ID?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngineInterface
     */
    ai_ENGINE_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngineInterface
     */
    user_ENGINE_DATE?: string;
}
/**
 * 
 * @export
 * @interface SensorGearboxInterface
 */
export interface SensorGearboxInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    g_V_OverallRMS?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    g_V_Wheel2X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    g_V_Pinion1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    g_V_GMF1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    g_V_Pinion2X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    g_V_Wheel1X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    g_V_GMF2X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    ai_GEAR?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorGearboxInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearboxInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearboxInterface
     */
    ai_GEAR_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearboxInterface
     */
    ai_GEAR_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearboxInterface
     */
    user_GEAR_ID?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorGearboxInterface
     */
    user_GEAR?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorGearboxInterface
     */
    user_GEAR_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearboxInterface
     */
    ai_GEAR_ALGO?: string;
}
/**
 * 
 * @export
 * @interface SensorWheelLeftInterface
 */
export interface SensorWheelLeftInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    l_W_V_2X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    l_W_V_3X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    ai_LW?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    l_W_S_Fault3?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelLeftInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelLeftInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelLeftInterface
     */
    user_LW_ID?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelLeftInterface
     */
    ai_LW_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelLeftInterface
     */
    ai_LW_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelLeftInterface
     */
    user_LW_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelLeftInterface
     */
    ai_LW_MODEL?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelLeftInterface
     */
    user_LW?: number;
}
/**
 * 
 * @export
 * @interface SensorWheelRightInterface
 */
export interface SensorWheelRightInterface {
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    w_RPM?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    ac_h?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    ac_v?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    ac_a?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    ai_RW?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    r_W_S_Fault3?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    r_W_V_2X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    r_W_V_3X?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelRightInterface
     */
    date?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelRightInterface
     */
    sdaId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelRightInterface
     */
    ai_RW_MODEL?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelRightInterface
     */
    ai_RW_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelRightInterface
     */
    user_RW_DATE?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelRightInterface
     */
    ai_RW_ALGO?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheelRightInterface
     */
    user_RW_ID?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorWheelRightInterface
     */
    user_RW?: number;
}
/**
 * 
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    userid?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    pwd?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    rnkcd?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    srvno?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    usedvcd?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    divs?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    brgd?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    bn?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    rspofc?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    telno1?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    telno2?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    usrth?: string;
}
/**
 * 
 * @export
 * @interface Snsr
 */
export interface Snsr {
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrnm?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrtype?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrdiv?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrunit?: string;
}
/**
 * 
 * @export
 * @interface StatisticalInfo
 */
export interface StatisticalInfo {
    /**
     * 
     * @type {string}
     * @memberof StatisticalInfo
     */
    level?: string;
    /**
     * 
     * @type {string}
     * @memberof StatisticalInfo
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof StatisticalInfo
     */
    date?: string;
}
/**
 * 
 * @export
 * @interface Threshold
 */
export interface Threshold {
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    expln?: string;
    /**
     * 
     * @type {number}
     * @memberof Threshold
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof Threshold
     */
    min?: number;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @interface TreeInfo
 */
export interface TreeInfo {
    /**
     * 
     * @type {number}
     * @memberof TreeInfo
     */
    trinfoid?: number;
    /**
     * 
     * @type {string}
     * @memberof TreeInfo
     */
    trinfoname?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeInfo
     */
    trinfocode?: string;
    /**
     * 
     * @type {number}
     * @memberof TreeInfo
     */
    trinfohead?: number;
}
/**
 * 
 * @export
 * @interface TroubleDataRequest
 */
export interface TroubleDataRequest {
    /**
     * 
     * @type {string}
     * @memberof TroubleDataRequest
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof TroubleDataRequest
     */
    part?: string;
    /**
     * 
     * @type {string}
     * @memberof TroubleDataRequest
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof TroubleDataRequest
     */
    endDate?: string;
    /**
     * 
     * @type {number}
     * @memberof TroubleDataRequest
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof TroubleDataRequest
     */
    size?: number;
}
/**
 * 
 * @export
 * @interface UpdateDataLookupInput
 */
export interface UpdateDataLookupInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    lookupName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    delimiter?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateDataLookupInput
     */
    indexOfLabeledField?: number;
}
/**
 * 
 * @export
 * @interface UpdateModelInput
 */
export interface UpdateModelInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateModelInput
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateModelInput
     */
    checked?: boolean;
}
/**
 * 
 * @export
 * @interface UserSnsr
 */
export interface UserSnsr {
    /**
     * 
     * @type {string}
     * @memberof UserSnsr
     */
    grpid?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSnsr
     */
    userid?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSnsr
     */
    snsrid?: string;
}
/**
 * 
 * @export
 * @interface Usercd
 */
export interface Usercd {
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    userid?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    pwd?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    usrth?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    rnkcd?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    srvno?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    usedvcd?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    blocktime?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    rctlogindt?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    rctpwdchngdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    divs?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    brgd?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    bn?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    rspofc?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    telno1?: string;
    /**
     * 
     * @type {string}
     * @memberof Usercd
     */
    telno2?: string;
    /**
     * 
     * @type {Set<Role>}
     * @memberof Usercd
     */
    roles?: Set<Role>;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser: async (loginRequest: LoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authenticateUser', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (signupRequest: SignupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('registerUser', 'signupRequest', signupRequest)
            const localVarPath = `/api/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin: async (authRequestDTO: AuthRequestDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRequestDTO' is not null or undefined
            assertParamExists('userLogin', 'authRequestDTO', authRequestDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUser(loginRequest: LoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(signupRequest: SignupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(signupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogin(authRequestDTO: AuthRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogin(authRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(loginRequest: LoginRequest, options?: any): AxiosPromise<object> {
            return localVarFp.authenticateUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(signupRequest: SignupRequest, options?: any): AxiosPromise<object> {
            return localVarFp.registerUser(signupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(authRequestDTO: AuthRequestDTO, options?: any): AxiosPromise<string> {
            return localVarFp.userLogin(authRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public authenticateUser(loginRequest: LoginRequest, options?: any) {
        return AuthControllerApiFp(this.configuration).authenticateUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignupRequest} signupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public registerUser(signupRequest: SignupRequest, options?: any) {
        return AuthControllerApiFp(this.configuration).registerUser(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthRequestDTO} authRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public userLogin(authRequestDTO: AuthRequestDTO, options?: any) {
        return AuthControllerApiFp(this.configuration).userLogin(authRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BoardControllerApi - axios parameter creator
 * @export
 */
export const BoardControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial3: async (board: Board, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'board' is not null or undefined
            assertParamExists('createTutorial3', 'board', board)
            const localVarPath = `/api/board/tutorials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(board, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTutorials: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/board/tutorials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTutorial: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTutorial', 'id', id)
            const localVarPath = `/api/board/tutorials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByPublished: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/board/tutorials/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBoard: async (title?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/board/tutorials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTutorialById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTutorialById', 'id', id)
            const localVarPath = `/api/board/tutorials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTutorial: async (id: number, board: Board, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTutorial', 'id', id)
            // verify required parameter 'board' is not null or undefined
            assertParamExists('updateTutorial', 'board', board)
            const localVarPath = `/api/board/tutorials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(board, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardControllerApi - functional programming interface
 * @export
 */
export const BoardControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial3(board: Board, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial3(board, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllTutorials(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HttpStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllTutorials(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTutorial(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HttpStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTutorial(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByPublished(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Board>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByPublished(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBoard(title?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Board>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBoard(title, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTutorialById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTutorialById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTutorial(id: number, board: Board, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTutorial(id, board, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoardControllerApi - factory interface
 * @export
 */
export const BoardControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial3(board: Board, options?: any): AxiosPromise<Board> {
            return localVarFp.createTutorial3(board, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTutorials(options?: any): AxiosPromise<HttpStatus> {
            return localVarFp.deleteAllTutorials(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTutorial(id: number, options?: any): AxiosPromise<HttpStatus> {
            return localVarFp.deleteTutorial(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByPublished(options?: any): AxiosPromise<Array<Board>> {
            return localVarFp.findByPublished(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBoard(title?: string, options?: any): AxiosPromise<Array<Board>> {
            return localVarFp.getAllBoard(title, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTutorialById(id: number, options?: any): AxiosPromise<Board> {
            return localVarFp.getTutorialById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTutorial(id: number, board: Board, options?: any): AxiosPromise<Board> {
            return localVarFp.updateTutorial(id, board, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardControllerApi - object-oriented interface
 * @export
 * @class BoardControllerApi
 * @extends {BaseAPI}
 */
export class BoardControllerApi extends BaseAPI {
    /**
     * 
     * @param {Board} board 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public createTutorial3(board: Board, options?: any) {
        return BoardControllerApiFp(this.configuration).createTutorial3(board, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public deleteAllTutorials(options?: any) {
        return BoardControllerApiFp(this.configuration).deleteAllTutorials(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public deleteTutorial(id: number, options?: any) {
        return BoardControllerApiFp(this.configuration).deleteTutorial(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public findByPublished(options?: any) {
        return BoardControllerApiFp(this.configuration).findByPublished(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public getAllBoard(title?: string, options?: any) {
        return BoardControllerApiFp(this.configuration).getAllBoard(title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public getTutorialById(id: number, options?: any) {
        return BoardControllerApiFp(this.configuration).getTutorialById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Board} board 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public updateTutorial(id: number, board: Board, options?: any) {
        return BoardControllerApiFp(this.configuration).updateTutorial(id, board, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CimControllerApi - axios parameter creator
 * @export
 */
export const CimControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmncd: async (cmncd: Cmncd, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmncd' is not null or undefined
            assertParamExists('createCmncd', 'cmncd', cmncd)
            const localVarPath = `/api/cim/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmncd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmncd: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCmncd', 'id', id)
            const localVarPath = `/api/cim/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncd: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCmncd', 'id', id)
            const localVarPath = `/api/cim/info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList2: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cim/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmncd: async (cmncd: Cmncd, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmncd' is not null or undefined
            assertParamExists('updateCmncd', 'cmncd', cmncd)
            const localVarPath = `/api/cim/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmncd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CimControllerApi - functional programming interface
 * @export
 */
export const CimControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CimControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCmncd(cmncd: Cmncd, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCmncd(cmncd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCmncd(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCmncd(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmncd(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmncd(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmncdList2(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmncdList2(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCmncd(cmncd: Cmncd, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCmncd(cmncd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CimControllerApi - factory interface
 * @export
 */
export const CimControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CimControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmncd(cmncd: Cmncd, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.createCmncd(cmncd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmncd(id: number, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.deleteCmncd(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncd(id: number, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.getCmncd(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList2(page?: number, pageSize?: number, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getCmncdList2(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmncd(cmncd: Cmncd, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.updateCmncd(cmncd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CimControllerApi - object-oriented interface
 * @export
 * @class CimControllerApi
 * @extends {BaseAPI}
 */
export class CimControllerApi extends BaseAPI {
    /**
     * 
     * @param {Cmncd} cmncd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public createCmncd(cmncd: Cmncd, options?: any) {
        return CimControllerApiFp(this.configuration).createCmncd(cmncd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public deleteCmncd(id: number, options?: any) {
        return CimControllerApiFp(this.configuration).deleteCmncd(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public getCmncd(id: number, options?: any) {
        return CimControllerApiFp(this.configuration).getCmncd(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public getCmncdList2(page?: number, pageSize?: number, options?: any) {
        return CimControllerApiFp(this.configuration).getCmncdList2(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Cmncd} cmncd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public updateCmncd(cmncd: Cmncd, options?: any) {
        return CimControllerApiFp(this.configuration).updateCmncd(cmncd, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseJudgementControllerApi - axios parameter creator
 * @export
 */
export const DatabaseJudgementControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDistinctByCarId: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('findDistinctByCarId', 'partType', partType)
            const localVarPath = `/api/judgement/cars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDistinctByModelName: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('findDistinctByModelName', 'partType', partType)
            const localVarPath = `/api/judgement/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftBallPredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingLeftBallPredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingLeftBallPredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-ball-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftInsidePredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingLeftInsidePredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingLeftInsidePredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-inside-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftOutsidePredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingLeftOutsidePredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingLeftOutsidePredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-outside-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftRetainerPredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingLeftRetainerPredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingLeftRetainerPredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-retainer-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightBallPredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingRightBallPredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingRightBallPredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-ball-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightInsidePredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingRightInsidePredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingRightInsidePredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-inside-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightOutsidePredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingRightOutsidePredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingRightOutsidePredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-outside-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightRetainerPredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getBearingRightRetainerPredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getBearingRightRetainerPredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-retainer-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnginePredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getEnginePredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getEnginePredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-engine-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineUserEngineData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getEngineUserEngineData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getEngineUserEngineData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-engine-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearboxPredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getGearboxPredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getGearboxPredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-gearbox-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearboxUserGearData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getGearboxUserGearData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getGearboxUserGearData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-gearbox-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftBallUserLBSFData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getLeftBallUserLBSFData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getLeftBallUserLBSFData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-ball-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftInsideUserLBPFIData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getLeftInsideUserLBPFIData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getLeftInsideUserLBPFIData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-inside-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftOutsideUserLBPFOData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getLeftOutsideUserLBPFOData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getLeftOutsideUserLBPFOData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-outside-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftRetainerUserLFTFData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getLeftRetainerUserLFTFData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getLeftRetainerUserLFTFData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-left-retainer-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftWheelUserLW: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getLeftWheelUserLW', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getLeftWheelUserLW', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-wheel-left-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightBallUserRBSFData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getRightBallUserRBSFData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getRightBallUserRBSFData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-ball-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightInsideUserRBPFIData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getRightInsideUserRBPFIData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getRightInsideUserRBPFIData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-inside-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightOutsideUserRBPFOData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getRightOutsideUserRBPFOData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getRightOutsideUserRBPFOData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-outside-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightRetainerUserRFTFData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getRightRetainerUserRFTFData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getRightRetainerUserRFTFData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-bearing-right-retainer-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightWheelUserRW: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getRightWheelUserRW', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getRightWheelUserRW', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-wheel-right-judged-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWheelLeftPredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getWheelLeftPredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getWheelLeftPredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-wheel-left-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWheelRightPredictedData: async (carId: string, modelName: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getWheelRightPredictedData', 'carId', carId)
            // verify required parameter 'modelName' is not null or undefined
            assertParamExists('getWheelRightPredictedData', 'modelName', modelName)
            const localVarPath = `/api/judgement/get-wheel-right-predicted-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (modelName !== undefined) {
                localVarQueryParameter['modelName'] = modelName;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<DbJudgementUpdateInput>} dbJudgementUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserJudgement: async (partType: string, dbJudgementUpdateInput: Array<DbJudgementUpdateInput>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('updateUserJudgement', 'partType', partType)
            // verify required parameter 'dbJudgementUpdateInput' is not null or undefined
            assertParamExists('updateUserJudgement', 'dbJudgementUpdateInput', dbJudgementUpdateInput)
            const localVarPath = `/api/judgement/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbJudgementUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseJudgementControllerApi - functional programming interface
 * @export
 */
export const DatabaseJudgementControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseJudgementControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDistinctByCarId(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDistinctByCarId(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDistinctByModelName(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDistinctByModelName(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingLeftBallPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftBallInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingLeftBallPredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingLeftInsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftInsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingLeftInsidePredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingLeftOutsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftOutsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingLeftOutsidePredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingLeftRetainerPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftRetainerInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingLeftRetainerPredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingRightBallPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightBallInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingRightBallPredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingRightInsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightInsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingRightInsidePredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingRightOutsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightOutsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingRightOutsidePredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBearingRightRetainerPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightRetainerInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBearingRightRetainerPredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnginePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorEngineInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnginePredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEngineUserEngineData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorEngineInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEngineUserEngineData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGearboxPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorGearboxInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGearboxPredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGearboxUserGearData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorGearboxInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGearboxUserGearData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeftBallUserLBSFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftBallInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeftBallUserLBSFData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeftInsideUserLBPFIData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftInsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeftInsideUserLBPFIData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeftOutsideUserLBPFOData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftOutsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeftOutsideUserLBPFOData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeftRetainerUserLFTFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingLeftRetainerInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeftRetainerUserLFTFData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLeftWheelUserLW(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorWheelLeftInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLeftWheelUserLW(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRightBallUserRBSFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightBallInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRightBallUserRBSFData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRightInsideUserRBPFIData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightInsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRightInsideUserRBPFIData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRightOutsideUserRBPFOData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightOutsideInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRightOutsideUserRBPFOData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRightRetainerUserRFTFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearingRightRetainerInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRightRetainerUserRFTFData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRightWheelUserRW(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorWheelRightInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRightWheelUserRW(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWheelLeftPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorWheelLeftInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWheelLeftPredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWheelRightPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorWheelRightInterface>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWheelRightPredictedData(carId, modelName, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<DbJudgementUpdateInput>} dbJudgementUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserJudgement(partType: string, dbJudgementUpdateInput: Array<DbJudgementUpdateInput>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserJudgement(partType, dbJudgementUpdateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseJudgementControllerApi - factory interface
 * @export
 */
export const DatabaseJudgementControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseJudgementControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDistinctByCarId(partType: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findDistinctByCarId(partType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDistinctByModelName(partType: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findDistinctByModelName(partType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftBallPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftBallInterface>> {
            return localVarFp.getBearingLeftBallPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftInsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftInsideInterface>> {
            return localVarFp.getBearingLeftInsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftOutsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftOutsideInterface>> {
            return localVarFp.getBearingLeftOutsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingLeftRetainerPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftRetainerInterface>> {
            return localVarFp.getBearingLeftRetainerPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightBallPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightBallInterface>> {
            return localVarFp.getBearingRightBallPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightInsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightInsideInterface>> {
            return localVarFp.getBearingRightInsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightOutsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightOutsideInterface>> {
            return localVarFp.getBearingRightOutsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBearingRightRetainerPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightRetainerInterface>> {
            return localVarFp.getBearingRightRetainerPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnginePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorEngineInterface>> {
            return localVarFp.getEnginePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEngineUserEngineData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorEngineInterface>> {
            return localVarFp.getEngineUserEngineData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearboxPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorGearboxInterface>> {
            return localVarFp.getGearboxPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearboxUserGearData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorGearboxInterface>> {
            return localVarFp.getGearboxUserGearData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftBallUserLBSFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftBallInterface>> {
            return localVarFp.getLeftBallUserLBSFData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftInsideUserLBPFIData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftInsideInterface>> {
            return localVarFp.getLeftInsideUserLBPFIData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftOutsideUserLBPFOData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftOutsideInterface>> {
            return localVarFp.getLeftOutsideUserLBPFOData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftRetainerUserLFTFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingLeftRetainerInterface>> {
            return localVarFp.getLeftRetainerUserLFTFData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLeftWheelUserLW(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorWheelLeftInterface>> {
            return localVarFp.getLeftWheelUserLW(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightBallUserRBSFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightBallInterface>> {
            return localVarFp.getRightBallUserRBSFData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightInsideUserRBPFIData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightInsideInterface>> {
            return localVarFp.getRightInsideUserRBPFIData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightOutsideUserRBPFOData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightOutsideInterface>> {
            return localVarFp.getRightOutsideUserRBPFOData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightRetainerUserRFTFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorBearingRightRetainerInterface>> {
            return localVarFp.getRightRetainerUserRFTFData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRightWheelUserRW(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorWheelRightInterface>> {
            return localVarFp.getRightWheelUserRW(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWheelLeftPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorWheelLeftInterface>> {
            return localVarFp.getWheelLeftPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} modelName 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWheelRightPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<SensorWheelRightInterface>> {
            return localVarFp.getWheelRightPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<DbJudgementUpdateInput>} dbJudgementUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserJudgement(partType: string, dbJudgementUpdateInput: Array<DbJudgementUpdateInput>, options?: any): AxiosPromise<string> {
            return localVarFp.updateUserJudgement(partType, dbJudgementUpdateInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseJudgementControllerApi - object-oriented interface
 * @export
 * @class DatabaseJudgementControllerApi
 * @extends {BaseAPI}
 */
export class DatabaseJudgementControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public findDistinctByCarId(partType: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).findDistinctByCarId(partType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public findDistinctByModelName(partType: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).findDistinctByModelName(partType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingLeftBallPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingLeftBallPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingLeftInsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingLeftInsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingLeftOutsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingLeftOutsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingLeftRetainerPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingLeftRetainerPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingRightBallPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingRightBallPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingRightInsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingRightInsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingRightOutsidePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingRightOutsidePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getBearingRightRetainerPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getBearingRightRetainerPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getEnginePredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getEnginePredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getEngineUserEngineData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getEngineUserEngineData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getGearboxPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getGearboxPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getGearboxUserGearData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getGearboxUserGearData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getLeftBallUserLBSFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getLeftBallUserLBSFData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getLeftInsideUserLBPFIData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getLeftInsideUserLBPFIData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getLeftOutsideUserLBPFOData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getLeftOutsideUserLBPFOData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getLeftRetainerUserLFTFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getLeftRetainerUserLFTFData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getLeftWheelUserLW(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getLeftWheelUserLW(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getRightBallUserRBSFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getRightBallUserRBSFData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getRightInsideUserRBPFIData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getRightInsideUserRBPFIData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getRightOutsideUserRBPFOData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getRightOutsideUserRBPFOData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getRightRetainerUserRFTFData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getRightRetainerUserRFTFData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getRightWheelUserRW(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getRightWheelUserRW(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getWheelLeftPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getWheelLeftPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} modelName 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public getWheelRightPredictedData(carId: string, modelName: string, fromDate?: string, toDate?: string, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).getWheelRightPredictedData(carId, modelName, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {Array<DbJudgementUpdateInput>} dbJudgementUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseJudgementControllerApi
     */
    public updateUserJudgement(partType: string, dbJudgementUpdateInput: Array<DbJudgementUpdateInput>, options?: any) {
        return DatabaseJudgementControllerApiFp(this.configuration).updateUserJudgement(partType, dbJudgementUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetControllerApi - axios parameter creator
 * @export
 */
export const DatasetControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataLookup: async (updateDataLookupInput: UpdateDataLookupInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDataLookupInput' is not null or undefined
            assertParamExists('createDataLookup', 'updateDataLookupInput', updateDataLookupInput)
            const localVarPath = `/api/data-lookup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataLookupInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataLookup: async (lookupName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lookupName' is not null or undefined
            assertParamExists('deleteDataLookup', 'lookupName', lookupName)
            const localVarPath = `/api/data-lookup/{lookupName}`
                .replace(`{${"lookupName"}}`, encodeURIComponent(String(lookupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDataLookups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data-lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataLookup: async (updateDataLookupInput: UpdateDataLookupInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDataLookupInput' is not null or undefined
            assertParamExists('updateDataLookup', 'updateDataLookupInput', updateDataLookupInput)
            const localVarPath = `/api/data-lookup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataLookupInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetControllerApi - functional programming interface
 * @export
 */
export const DatasetControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataLookup(updateDataLookupInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataLookup(lookupName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataLookup(lookupName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDataLookups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataLookup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDataLookups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataLookup(updateDataLookupInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetControllerApi - factory interface
 * @export
 */
export const DatasetControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.createDataLookup(updateDataLookupInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataLookup(lookupName: string, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.deleteDataLookup(lookupName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDataLookups(options?: any): AxiosPromise<Array<DataLookup>> {
            return localVarFp.getAllDataLookups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.updateDataLookup(updateDataLookupInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetControllerApi - object-oriented interface
 * @export
 * @class DatasetControllerApi
 * @extends {BaseAPI}
 */
export class DatasetControllerApi extends BaseAPI {
    /**
     * 
     * @param {UpdateDataLookupInput} updateDataLookupInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).createDataLookup(updateDataLookupInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lookupName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public deleteDataLookup(lookupName: string, options?: any) {
        return DatasetControllerApiFp(this.configuration).deleteDataLookup(lookupName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getAllDataLookups(options?: any) {
        return DatasetControllerApiFp(this.configuration).getAllDataLookups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDataLookupInput} updateDataLookupInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).updateDataLookup(updateDataLookupInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetDatabaseControllerApi - axios parameter creator
 * @export
 */
export const DatasetDatabaseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDistinctByCarIdFromLifeData: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('findDistinctByCarIdFromLifeData', 'partType', partType)
            const localVarPath = `/api/data/database/life/cars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingBearingData: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getTrainingBearingData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-labeled-bearing-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingBearingLifeData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/database/get-all-labeled-bearing-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingEngineData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/database/get-all-labeled-engine-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingEngineLifeData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/database/get-all-labeled-engine-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingGearboxData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/database/get-all-labeled-gearbox-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingGearboxLifeData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/database/get-all-labeled-gearbox-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingWheelData: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getTrainingWheelData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-labeled-wheel-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingWheelLifeData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/database/get-all-labeled-wheel-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledBearingData: async (carId: string, partType: string, fromDate?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledBearingData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledBearingData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-bearing-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledBearingLifeData: async (carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledBearingLifeData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledBearingLifeData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-bearing-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledEngineData: async (carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledEngineData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledEngineData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-engine-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledEngineLifeData: async (carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledEngineLifeData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledEngineLifeData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-engine-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledGearboxData: async (carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledGearboxData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledGearboxData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-gearbox-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledGearboxLifeData: async (carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledGearboxLifeData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledGearboxLifeData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-gearbox-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledWheelData: async (carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledWheelData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledWheelData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-wheel-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledWheelLifeData: async (carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'carId' is not null or undefined
            assertParamExists('getUnlabeledWheelLifeData', 'carId', carId)
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getUnlabeledWheelLifeData', 'partType', partType)
            const localVarPath = `/api/data/database/get-all-unlabeled-wheel-life-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (carId !== undefined) {
                localVarQueryParameter['carId'] = carId;
            }

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateData: async (dbDataUpdateInput: Array<DbDataUpdateInput>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbDataUpdateInput' is not null or undefined
            assertParamExists('updateData', 'dbDataUpdateInput', dbDataUpdateInput)
            const localVarPath = `/api/data/database/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbDataUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCSVFileAndImportDB: async (partType: string, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('uploadCSVFileAndImportDB', 'partType', partType)
            const localVarPath = `/api/data/database/upload-dataset-file-to-database/{partType}`
                .replace(`{${"partType"}}`, encodeURIComponent(String(partType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetDatabaseControllerApi - functional programming interface
 * @export
 */
export const DatasetDatabaseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetDatabaseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDistinctByCarIdFromLifeData(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDistinctByCarIdFromLifeData(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingBearingData(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingBearingData(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingBearingLifeData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingBearingLifeData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingEngineData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingEngineData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingEngineLifeData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingEngineLifeData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingGearboxData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingGearboxData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingGearboxLifeData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingGearboxLifeData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingWheelData(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingWheelData(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingWheelLifeData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingWheelLifeData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledBearingData(carId: string, partType: string, fromDate?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledBearingData(carId, partType, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledBearingLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledBearingLifeData(carId, partType, fromDate, toDate, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledEngineData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledEngineData(carId, partType, fromDate, toDate, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledEngineLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledEngineLifeData(carId, partType, fromDate, toDate, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledGearboxData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledGearboxData(carId, partType, fromDate, toDate, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledGearboxLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledGearboxLifeData(carId, partType, fromDate, toDate, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledWheelData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledWheelData(carId, partType, fromDate, toDate, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledWheelLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledWheelLifeData(carId, partType, fromDate, toDate, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateData(dbDataUpdateInput: Array<DbDataUpdateInput>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateData(dbDataUpdateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCSVFileAndImportDB(partType: string, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCSVFileAndImportDB(partType, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetDatabaseControllerApi - factory interface
 * @export
 */
export const DatasetDatabaseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetDatabaseControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDistinctByCarIdFromLifeData(partType: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findDistinctByCarIdFromLifeData(partType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingBearingData(partType: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingBearingData(partType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingBearingLifeData(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingBearingLifeData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingEngineData(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingEngineData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingEngineLifeData(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingEngineLifeData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingGearboxData(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingGearboxData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingGearboxLifeData(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingGearboxLifeData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingWheelData(partType: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingWheelData(partType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingWheelLifeData(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTrainingWheelLifeData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledBearingData(carId: string, partType: string, fromDate?: string, toDate?: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledBearingData(carId, partType, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledBearingLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledBearingLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledEngineData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledEngineData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledEngineLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledEngineLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledGearboxData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledGearboxData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledGearboxLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledGearboxLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledWheelData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledWheelData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} carId 
         * @param {string} partType 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledWheelLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getUnlabeledWheelLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateData(dbDataUpdateInput: Array<DbDataUpdateInput>, options?: any): AxiosPromise<string> {
            return localVarFp.updateData(dbDataUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCSVFileAndImportDB(partType: string, files?: Array<any>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.uploadCSVFileAndImportDB(partType, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetDatabaseControllerApi - object-oriented interface
 * @export
 * @class DatasetDatabaseControllerApi
 * @extends {BaseAPI}
 */
export class DatasetDatabaseControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public findDistinctByCarIdFromLifeData(partType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).findDistinctByCarIdFromLifeData(partType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingBearingData(partType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingBearingData(partType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingBearingLifeData(options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingBearingLifeData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingEngineData(options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingEngineData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingEngineLifeData(options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingEngineLifeData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingGearboxData(options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingGearboxData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingGearboxLifeData(options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingGearboxLifeData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingWheelData(partType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingWheelData(partType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getTrainingWheelLifeData(options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getTrainingWheelLifeData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledBearingData(carId: string, partType: string, fromDate?: string, toDate?: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledBearingData(carId, partType, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledBearingLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledBearingLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledEngineData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledEngineData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledEngineLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledEngineLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledGearboxData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledGearboxData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledGearboxLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledGearboxLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledWheelData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledWheelData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} carId 
     * @param {string} partType 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledWheelLifeData(carId: string, partType: string, fromDate?: string, toDate?: string, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledWheelLifeData(carId, partType, fromDate, toDate, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public updateData(dbDataUpdateInput: Array<DbDataUpdateInput>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).updateData(dbDataUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {Array<any>} [files] Files to be uploaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public uploadCSVFileAndImportDB(partType: string, files?: Array<any>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).uploadCSVFileAndImportDB(partType, files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverCorrectionControllerApi - axios parameter creator
 * @export
 */
export const DriverCorrectionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList2: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getBnList2', 'data', data)
            const localVarPath = `/api/drivercorrection/bnList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/drivercorrection/divsList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdaList1: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getSdaList1', 'data', data)
            const localVarPath = `/api/drivercorrection/sdaList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1: async (searchRequest: SearchRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists('search1', 'searchRequest', searchRequest)
            const localVarPath = `/api/drivercorrection/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverCorrectionControllerApi - functional programming interface
 * @export
 */
export const DriverCorrectionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverCorrectionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBnList2(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBnList2(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDivList2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDivList2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdaList1(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdaList1(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search1(searchRequest: SearchRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search1(searchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverCorrectionControllerApi - factory interface
 * @export
 */
export const DriverCorrectionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverCorrectionControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList2(data: string, options?: any): AxiosPromise<Array<TreeInfo>> {
            return localVarFp.getBnList2(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList2(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getDivList2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdaList1(data: string, options?: any): AxiosPromise<Array<Sda>> {
            return localVarFp.getSdaList1(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search1(searchRequest: SearchRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.search1(searchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriverCorrectionControllerApi - object-oriented interface
 * @export
 * @class DriverCorrectionControllerApi
 * @extends {BaseAPI}
 */
export class DriverCorrectionControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public getBnList2(data: string, options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).getBnList2(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public getDivList2(options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).getDivList2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public getSdaList1(data: string, options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).getSdaList1(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchRequest} searchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public search1(searchRequest: SearchRequest, options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).search1(searchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverCorrectionSettingControllerApi - axios parameter creator
 * @export
 */
export const DriverCorrectionSettingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<DriverAttitd>} driverAttitd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial2: async (driverAttitd: Array<DriverAttitd>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'driverAttitd' is not null or undefined
            assertParamExists('createTutorial2', 'driverAttitd', driverAttitd)
            const localVarPath = `/api/driverPostureCorrection/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driverAttitd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSnsrList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/driverPostureCorrection/snsrlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList3: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/driverPostureCorrection/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverCorrectionSettingControllerApi - functional programming interface
 * @export
 */
export const DriverCorrectionSettingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverCorrectionSettingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<DriverAttitd>} driverAttitd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial2(driverAttitd: Array<DriverAttitd>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverAttitd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial2(driverAttitd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSnsrList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Snsr>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSnsrList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholdList3(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverAttitd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholdList3(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverCorrectionSettingControllerApi - factory interface
 * @export
 */
export const DriverCorrectionSettingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverCorrectionSettingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<DriverAttitd>} driverAttitd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial2(driverAttitd: Array<DriverAttitd>, options?: any): AxiosPromise<DriverAttitd> {
            return localVarFp.createTutorial2(driverAttitd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSnsrList(options?: any): AxiosPromise<Array<Snsr>> {
            return localVarFp.findSnsrList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList3(options?: any): AxiosPromise<Array<DriverAttitd>> {
            return localVarFp.getThresholdList3(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriverCorrectionSettingControllerApi - object-oriented interface
 * @export
 * @class DriverCorrectionSettingControllerApi
 * @extends {BaseAPI}
 */
export class DriverCorrectionSettingControllerApi extends BaseAPI {
    /**
     * 
     * @param {Array<DriverAttitd>} driverAttitd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionSettingControllerApi
     */
    public createTutorial2(driverAttitd: Array<DriverAttitd>, options?: any) {
        return DriverCorrectionSettingControllerApiFp(this.configuration).createTutorial2(driverAttitd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionSettingControllerApi
     */
    public findSnsrList(options?: any) {
        return DriverCorrectionSettingControllerApiFp(this.configuration).findSnsrList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionSettingControllerApi
     */
    public getThresholdList3(options?: any) {
        return DriverCorrectionSettingControllerApiFp(this.configuration).getThresholdList3(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LifeThresholdControllerApi - axios parameter creator
 * @export
 */
export const LifeThresholdControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/lifethreshold/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<LifeThreshold>} lifeThreshold 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (lifeThreshold: Array<LifeThreshold>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lifeThreshold' is not null or undefined
            assertParamExists('update', 'lifeThreshold', lifeThreshold)
            const localVarPath = `/api/lifethreshold/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lifeThreshold, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifeThresholdControllerApi - functional programming interface
 * @export
 */
export const LifeThresholdControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifeThresholdControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholdList2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LifeThreshold>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholdList2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<LifeThreshold>} lifeThreshold 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(lifeThreshold: Array<LifeThreshold>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifeThreshold>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(lifeThreshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LifeThresholdControllerApi - factory interface
 * @export
 */
export const LifeThresholdControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifeThresholdControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList2(options?: any): AxiosPromise<Array<LifeThreshold>> {
            return localVarFp.getThresholdList2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<LifeThreshold>} lifeThreshold 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(lifeThreshold: Array<LifeThreshold>, options?: any): AxiosPromise<LifeThreshold> {
            return localVarFp.update(lifeThreshold, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LifeThresholdControllerApi - object-oriented interface
 * @export
 * @class LifeThresholdControllerApi
 * @extends {BaseAPI}
 */
export class LifeThresholdControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifeThresholdControllerApi
     */
    public getThresholdList2(options?: any) {
        return LifeThresholdControllerApiFp(this.configuration).getThresholdList2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<LifeThreshold>} lifeThreshold 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifeThresholdControllerApi
     */
    public update(lifeThreshold: Array<LifeThreshold>, options?: any) {
        return LifeThresholdControllerApiFp(this.configuration).update(lifeThreshold, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LifeThresholdFindControllerApi - axios parameter creator
 * @export
 */
export const LifeThresholdFindControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findThreshold: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('findThreshold', 'partType', partType)
            const localVarPath = `/api/threshold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (partType !== undefined) {
                localVarQueryParameter['partType'] = partType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LifeThresholdFindControllerApi - functional programming interface
 * @export
 */
export const LifeThresholdFindControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LifeThresholdFindControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findThreshold(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LifeThreshold>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findThreshold(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LifeThresholdFindControllerApi - factory interface
 * @export
 */
export const LifeThresholdFindControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LifeThresholdFindControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findThreshold(partType: string, options?: any): AxiosPromise<LifeThreshold> {
            return localVarFp.findThreshold(partType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LifeThresholdFindControllerApi - object-oriented interface
 * @export
 * @class LifeThresholdFindControllerApi
 * @extends {BaseAPI}
 */
export class LifeThresholdFindControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LifeThresholdFindControllerApi
     */
    public findThreshold(partType: string, options?: any) {
        return LifeThresholdFindControllerApiFp(this.configuration).findThreshold(partType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MlControllerApi - axios parameter creator
 * @export
 */
export const MlControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chiSquareFS: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('chiSquareFS', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/fs/chi-sq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationPredict: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('classificationPredict', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('classificationPredict', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/classification-predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (algorithm: string, algorithmResponseId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('deleteModel', 'algorithm', algorithm)
            // verify required parameter 'algorithmResponseId' is not null or undefined
            assertParamExists('deleteModel', 'algorithmResponseId', algorithmResponseId)
            const localVarPath = `/api/ml/{algorithm}/model/{algorithmResponseId}`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)))
                .replace(`{${"algorithmResponseId"}}`, encodeURIComponent(String(algorithmResponseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels: async (algorithm: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('getModels', 'algorithm', algorithm)
            const localVarPath = `/api/ml/{algorithm}/models`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataList: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getTrainingDataList', 'partType', partType)
            const localVarPath = `/api/get-trainingData/{partType}`
                .replace(`{${"partType"}}`, encodeURIComponent(String(partType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcaDimensionalityReduction: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('pcaDimensionalityReduction', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/fs/pca`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictCluster: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('predictCluster', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('predictCluster', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/cluster-predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regressionPredict: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('regressionPredict', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('regressionPredict', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/regression-predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainIF: async (reTrainingInput: ReTrainingInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reTrainingInput' is not null or undefined
            assertParamExists('retrainIF', 'reTrainingInput', reTrainingInput)
            const localVarPath = `/api/retrain/if`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reTrainingInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainLr: async (reTrainingInput: ReTrainingInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reTrainingInput' is not null or undefined
            assertParamExists('retrainLr', 'reTrainingInput', reTrainingInput)
            const localVarPath = `/api/retrain/lr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reTrainingInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainMLP: async (reTrainingInput: ReTrainingInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reTrainingInput' is not null or undefined
            assertParamExists('retrainMLP', 'reTrainingInput', reTrainingInput)
            const localVarPath = `/api/retrain/mlp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reTrainingInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainRfc: async (reTrainingInput: ReTrainingInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reTrainingInput' is not null or undefined
            assertParamExists('retrainRfc', 'reTrainingInput', reTrainingInput)
            const localVarPath = `/api/retrain/rfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reTrainingInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainSVC: async (reTrainingInput: ReTrainingInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'reTrainingInput' is not null or undefined
            assertParamExists('retrainSVC', 'reTrainingInput', reTrainingInput)
            const localVarPath = `/api/retrain/svc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reTrainingInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainIsolationForest: async (clusterTrainInput: ClusterTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterTrainInput' is not null or undefined
            assertParamExists('trainIsolationForest', 'clusterTrainInput', clusterTrainInput)
            const localVarPath = `/api/train/if`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLassoRegression: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLassoRegression', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/lasso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinearRegression: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLinearRegression', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/linear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLr: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLr', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/lr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainMLP: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainMLP', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/mlp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainRfc: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainRfc', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/rfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainSVC: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainSVC', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/svc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel: async (algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('updateModel', 'algorithm', algorithm)
            // verify required parameter 'algorithmResponseId' is not null or undefined
            assertParamExists('updateModel', 'algorithmResponseId', algorithmResponseId)
            // verify required parameter 'updateModelInput' is not null or undefined
            assertParamExists('updateModel', 'updateModelInput', updateModelInput)
            const localVarPath = `/api/ml/{algorithm}/model/{algorithmResponseId}`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)))
                .replace(`{${"algorithmResponseId"}}`, encodeURIComponent(String(algorithmResponseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateModelInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MlControllerApi - functional programming interface
 * @export
 */
export const MlControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MlControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FSResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chiSquareFS(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationPredict(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(algorithm: string, algorithmResponseId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(algorithm, algorithmResponseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModels(algorithm: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DbModelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModels(algorithm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingDataList(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingDataList(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FSResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcaDimensionalityReduction(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictCluster(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regressionPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regressionPredict(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrainIF(reTrainingInput: ReTrainingInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrainIF(reTrainingInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrainLr(reTrainingInput: ReTrainingInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrainLr(reTrainingInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrainMLP(reTrainingInput: ReTrainingInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrainMLP(reTrainingInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrainRfc(reTrainingInput: ReTrainingInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RandomForestClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrainRfc(reTrainingInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrainSVC(reTrainingInput: ReTrainingInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrainSVC(reTrainingInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainIsolationForest(clusterTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLassoRegression(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLinearRegression(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLr(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainMLP(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RandomForestClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainRfc(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainSVC(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainSVC(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DbModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModel(algorithm, algorithmResponseId, updateModelInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MlControllerApi - factory interface
 * @export
 */
export const MlControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MlControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<FSResponse> {
            return localVarFp.chiSquareFS(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.classificationPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(algorithm: string, algorithmResponseId: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteModel(algorithm, algorithmResponseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(algorithm: string, options?: any): AxiosPromise<Array<DbModelResponse>> {
            return localVarFp.getModels(algorithm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataList(partType: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTrainingDataList(partType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<FSResponse> {
            return localVarFp.pcaDimensionalityReduction(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.predictCluster(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regressionPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.regressionPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainIF(reTrainingInput: ReTrainingInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.retrainIF(reTrainingInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainLr(reTrainingInput: ReTrainingInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.retrainLr(reTrainingInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainMLP(reTrainingInput: ReTrainingInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.retrainMLP(reTrainingInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainRfc(reTrainingInput: ReTrainingInput, options?: any): AxiosPromise<RandomForestClassificationResponse> {
            return localVarFp.retrainRfc(reTrainingInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ReTrainingInput} reTrainingInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrainSVC(reTrainingInput: ReTrainingInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.retrainSVC(reTrainingInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.trainIsolationForest(clusterTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.trainLassoRegression(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.trainLinearRegression(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainLr(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainMLP(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RandomForestClassificationResponse> {
            return localVarFp.trainRfc(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainSVC(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainSVC(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any): AxiosPromise<DbModelResponse> {
            return localVarFp.updateModel(algorithm, algorithmResponseId, updateModelInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MlControllerApi - object-oriented interface
 * @export
 * @class MlControllerApi
 * @extends {BaseAPI}
 */
export class MlControllerApi extends BaseAPI {
    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).chiSquareFS(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public classificationPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).classificationPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {number} algorithmResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public deleteModel(algorithm: string, algorithmResponseId: number, options?: any) {
        return MlControllerApiFp(this.configuration).deleteModel(algorithm, algorithmResponseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getModels(algorithm: string, options?: any) {
        return MlControllerApiFp(this.configuration).getModels(algorithm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getTrainingDataList(partType: string, options?: any) {
        return MlControllerApiFp(this.configuration).getTrainingDataList(partType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).pcaDimensionalityReduction(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).predictCluster(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public regressionPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).regressionPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReTrainingInput} reTrainingInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public retrainIF(reTrainingInput: ReTrainingInput, options?: any) {
        return MlControllerApiFp(this.configuration).retrainIF(reTrainingInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReTrainingInput} reTrainingInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public retrainLr(reTrainingInput: ReTrainingInput, options?: any) {
        return MlControllerApiFp(this.configuration).retrainLr(reTrainingInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReTrainingInput} reTrainingInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public retrainMLP(reTrainingInput: ReTrainingInput, options?: any) {
        return MlControllerApiFp(this.configuration).retrainMLP(reTrainingInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReTrainingInput} reTrainingInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public retrainRfc(reTrainingInput: ReTrainingInput, options?: any) {
        return MlControllerApiFp(this.configuration).retrainRfc(reTrainingInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ReTrainingInput} reTrainingInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public retrainSVC(reTrainingInput: ReTrainingInput, options?: any) {
        return MlControllerApiFp(this.configuration).retrainSVC(reTrainingInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClusterTrainInput} clusterTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainIsolationForest(clusterTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLassoRegression(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLinearRegression(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLr(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainMLP(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainRfc(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainSVC(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainSVC(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {number} algorithmResponseId 
     * @param {UpdateModelInput} updateModelInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any) {
        return MlControllerApiFp(this.configuration).updateModel(algorithm, algorithmResponseId, updateModelInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MonitorDiagnosControllerApi - axios parameter creator
 * @export
 */
export const MonitorDiagnosControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ExcelDownByMonitorDiagnos} excelDownByMonitorDiagnos 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelDownLoad: async (excelDownByMonitorDiagnos: ExcelDownByMonitorDiagnos, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'excelDownByMonitorDiagnos' is not null or undefined
            assertParamExists('excelDownLoad', 'excelDownByMonitorDiagnos', excelDownByMonitorDiagnos)
            const localVarPath = `/api/monitordiagnost/downloadExcel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(excelDownByMonitorDiagnos, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicleInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/monitordiagnost/getAllVehicle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ParamdescRequest} paramdescRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParamdesc: async (paramdescRequest: ParamdescRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paramdescRequest' is not null or undefined
            assertParamExists('getParamdesc', 'paramdescRequest', paramdescRequest)
            const localVarPath = `/api/monitordiagnost/searchParamdesc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paramdescRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getSimulation', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitordiagnost/searchSimulation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreshold: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/monitordiagnost/getThreshold`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleBer: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getTroubleBer', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitordiagnost/searchTroubleBer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleEng: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getTroubleEng', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitordiagnost/searchTroubleEng`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleGrb: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getTroubleGrb', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitordiagnost/searchTroubleGrb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleWhl: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getTroubleWhl', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitordiagnost/searchTroubleWhl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonitorDiagnosControllerApi - functional programming interface
 * @export
 */
export const MonitorDiagnosControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonitorDiagnosControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ExcelDownByMonitorDiagnos} excelDownByMonitorDiagnos 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async excelDownLoad(excelDownByMonitorDiagnos: ExcelDownByMonitorDiagnos, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.excelDownLoad(excelDownByMonitorDiagnos, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVehicleInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVehicleInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ParamdescRequest} paramdescRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParamdesc(paramdescRequest: ParamdescRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Paramdesc>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParamdesc(paramdescRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSimulation(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSimulation(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThreshold(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Threshold>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThreshold(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTroubleBer(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTroubleBer(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTroubleEng(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTroubleEng(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTroubleGrb(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTroubleGrb(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTroubleWhl(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTroubleWhl(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonitorDiagnosControllerApi - factory interface
 * @export
 */
export const MonitorDiagnosControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonitorDiagnosControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ExcelDownByMonitorDiagnos} excelDownByMonitorDiagnos 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        excelDownLoad(excelDownByMonitorDiagnos: ExcelDownByMonitorDiagnos, options?: any): AxiosPromise<void> {
            return localVarFp.excelDownLoad(excelDownByMonitorDiagnos, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicleInfo(options?: any): AxiosPromise<Array<Sda>> {
            return localVarFp.getAllVehicleInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ParamdescRequest} paramdescRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParamdesc(paramdescRequest: ParamdescRequest, options?: any): AxiosPromise<Array<Paramdesc>> {
            return localVarFp.getParamdesc(paramdescRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSimulation(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getSimulation(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThreshold(options?: any): AxiosPromise<Array<Threshold>> {
            return localVarFp.getThreshold(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleBer(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getTroubleBer(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleEng(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getTroubleEng(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleGrb(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getTroubleGrb(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTroubleWhl(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getTroubleWhl(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonitorDiagnosControllerApi - object-oriented interface
 * @export
 * @class MonitorDiagnosControllerApi
 * @extends {BaseAPI}
 */
export class MonitorDiagnosControllerApi extends BaseAPI {
    /**
     * 
     * @param {ExcelDownByMonitorDiagnos} excelDownByMonitorDiagnos 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public excelDownLoad(excelDownByMonitorDiagnos: ExcelDownByMonitorDiagnos, options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).excelDownLoad(excelDownByMonitorDiagnos, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getAllVehicleInfo(options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getAllVehicleInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ParamdescRequest} paramdescRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getParamdesc(paramdescRequest: ParamdescRequest, options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getParamdesc(paramdescRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getSimulation(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getSimulation(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getThreshold(options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getThreshold(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getTroubleBer(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getTroubleBer(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getTroubleEng(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getTroubleEng(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getTroubleGrb(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getTroubleGrb(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorDiagnosControllerApi
     */
    public getTroubleWhl(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorDiagnosControllerApiFp(this.configuration).getTroubleWhl(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MonitorRemainingControllerApi - axios parameter creator
 * @export
 */
export const MonitorRemainingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBerlife: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getBerlife', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitorremaining/searchBerlife`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnglife: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getEnglife', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitorremaining/searchEnglife`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrblife: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getGrblife', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitorremaining/searchGrblife`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhllife: async (troubleDataRequest: TroubleDataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'troubleDataRequest' is not null or undefined
            assertParamExists('getWhllife', 'troubleDataRequest', troubleDataRequest)
            const localVarPath = `/api/monitorremaining/searchWhllife`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(troubleDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonitorRemainingControllerApi - functional programming interface
 * @export
 */
export const MonitorRemainingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MonitorRemainingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBerlife(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBerlife(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnglife(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnglife(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGrblife(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGrblife(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWhllife(troubleDataRequest: TroubleDataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWhllife(troubleDataRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MonitorRemainingControllerApi - factory interface
 * @export
 */
export const MonitorRemainingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MonitorRemainingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBerlife(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getBerlife(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnglife(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getEnglife(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGrblife(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getGrblife(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TroubleDataRequest} troubleDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWhllife(troubleDataRequest: TroubleDataRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getWhllife(troubleDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MonitorRemainingControllerApi - object-oriented interface
 * @export
 * @class MonitorRemainingControllerApi
 * @extends {BaseAPI}
 */
export class MonitorRemainingControllerApi extends BaseAPI {
    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorRemainingControllerApi
     */
    public getBerlife(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorRemainingControllerApiFp(this.configuration).getBerlife(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorRemainingControllerApi
     */
    public getEnglife(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorRemainingControllerApiFp(this.configuration).getEnglife(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorRemainingControllerApi
     */
    public getGrblife(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorRemainingControllerApiFp(this.configuration).getGrblife(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TroubleDataRequest} troubleDataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MonitorRemainingControllerApi
     */
    public getWhllife(troubleDataRequest: TroubleDataRequest, options?: any) {
        return MonitorRemainingControllerApiFp(this.configuration).getWhllife(troubleDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartsReplacementCycleSettingControllerApi - axios parameter creator
 * @export
 */
export const PartsReplacementCycleSettingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CmpntsrplcData} cmpntsrplcData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (cmpntsrplcData: CmpntsrplcData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmpntsrplcData' is not null or undefined
            assertParamExists('add', 'cmpntsrplcData', cmpntsrplcData)
            const localVarPath = `/api/partsreplacementcycle/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmpntsrplcData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Cmpntsrplc>} cmpntsrplc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial1: async (cmpntsrplc: Array<Cmpntsrplc>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmpntsrplc' is not null or undefined
            assertParamExists('createTutorial1', 'cmpntsrplc', cmpntsrplc)
            const localVarPath = `/api/partsreplacementcycle/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmpntsrplc, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList1: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getBnList1', 'data', data)
            const localVarPath = `/api/partsreplacementcycle/bnList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList1: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getCmncdList1', 'data', data)
            const localVarPath = `/api/partsreplacementcycle/cmncdList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/partsreplacementcycle/divsList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdaList: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getSdaList', 'data', data)
            const localVarPath = `/api/partsreplacementcycle/vnList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/partsreplacementcycle/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CmpntsrplcHistry} cmpntsrplcHistry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        history: async (cmpntsrplcHistry: CmpntsrplcHistry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmpntsrplcHistry' is not null or undefined
            assertParamExists('history', 'cmpntsrplcHistry', cmpntsrplcHistry)
            const localVarPath = `/api/partsreplacementcycle/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmpntsrplcHistry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (requestBody: { [key: string]: object; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('search', 'requestBody', requestBody)
            const localVarPath = `/api/partsreplacementcycle/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartsReplacementCycleSettingControllerApi - functional programming interface
 * @export
 */
export const PartsReplacementCycleSettingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartsReplacementCycleSettingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CmpntsrplcData} cmpntsrplcData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(cmpntsrplcData: CmpntsrplcData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmpntsrplcHistry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add(cmpntsrplcData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Cmpntsrplc>} cmpntsrplc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial1(cmpntsrplc: Array<Cmpntsrplc>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmpntsrplc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial1(cmpntsrplc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBnList1(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBnList1(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmncdList1(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmncdList1(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDivList1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDivList1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdaList(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdaList(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholdList1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmpntsrplcResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholdList1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CmpntsrplcHistry} cmpntsrplcHistry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async history(cmpntsrplcHistry: CmpntsrplcHistry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmpntsrplcHistry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.history(cmpntsrplcHistry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(requestBody: { [key: string]: object; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmpntsrplcInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartsReplacementCycleSettingControllerApi - factory interface
 * @export
 */
export const PartsReplacementCycleSettingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartsReplacementCycleSettingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CmpntsrplcData} cmpntsrplcData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(cmpntsrplcData: CmpntsrplcData, options?: any): AxiosPromise<Array<CmpntsrplcHistry>> {
            return localVarFp.add(cmpntsrplcData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Cmpntsrplc>} cmpntsrplc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial1(cmpntsrplc: Array<Cmpntsrplc>, options?: any): AxiosPromise<Cmpntsrplc> {
            return localVarFp.createTutorial1(cmpntsrplc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList1(data: string, options?: any): AxiosPromise<Array<TreeInfo>> {
            return localVarFp.getBnList1(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList1(data: string, options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getCmncdList1(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList1(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getDivList1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdaList(data: string, options?: any): AxiosPromise<Array<Sda>> {
            return localVarFp.getSdaList(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList1(options?: any): AxiosPromise<Array<CmpntsrplcResponse>> {
            return localVarFp.getThresholdList1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CmpntsrplcHistry} cmpntsrplcHistry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        history(cmpntsrplcHistry: CmpntsrplcHistry, options?: any): AxiosPromise<Array<CmpntsrplcHistry>> {
            return localVarFp.history(cmpntsrplcHistry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {{ [key: string]: object; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(requestBody: { [key: string]: object; }, options?: any): AxiosPromise<Array<CmpntsrplcInfo>> {
            return localVarFp.search(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartsReplacementCycleSettingControllerApi - object-oriented interface
 * @export
 * @class PartsReplacementCycleSettingControllerApi
 * @extends {BaseAPI}
 */
export class PartsReplacementCycleSettingControllerApi extends BaseAPI {
    /**
     * 
     * @param {CmpntsrplcData} cmpntsrplcData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public add(cmpntsrplcData: CmpntsrplcData, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).add(cmpntsrplcData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Cmpntsrplc>} cmpntsrplc 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public createTutorial1(cmpntsrplc: Array<Cmpntsrplc>, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).createTutorial1(cmpntsrplc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public getBnList1(data: string, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).getBnList1(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public getCmncdList1(data: string, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).getCmncdList1(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public getDivList1(options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).getDivList1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public getSdaList(data: string, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).getSdaList(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public getThresholdList1(options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).getThresholdList1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CmpntsrplcHistry} cmpntsrplcHistry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public history(cmpntsrplcHistry: CmpntsrplcHistry, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).history(cmpntsrplcHistry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {{ [key: string]: object; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public search(requestBody: { [key: string]: object; }, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).search(requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatisticalInfoControllerApi - axios parameter creator
 * @export
 */
export const StatisticalInfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraph: async (statisticalInfo: StatisticalInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'statisticalInfo' is not null or undefined
            assertParamExists('getGraph', 'statisticalInfo', statisticalInfo)
            const localVarPath = `/api/statistical/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticalInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getId: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getId', 'name', name)
            const localVarPath = `/api/statistical/getId/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/statistical/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopUpInfo: async (userid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('getPopUpInfo', 'userid', userid)
            const localVarPath = `/api/statistical/getPopUpInfo/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable: async (statisticalInfo: StatisticalInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'statisticalInfo' is not null or undefined
            assertParamExists('getTable', 'statisticalInfo', statisticalInfo)
            const localVarPath = `/api/statistical/table`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticalInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticalInfoControllerApi - functional programming interface
 * @export
 */
export const StatisticalInfoControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticalInfoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraph(statisticalInfo: StatisticalInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraph(statisticalInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getId(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getId(name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPopUpInfo(userid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPopUpInfo(userid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTable(statisticalInfo: StatisticalInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTable(statisticalInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticalInfoControllerApi - factory interface
 * @export
 */
export const StatisticalInfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticalInfoControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraph(statisticalInfo: StatisticalInfo, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getGraph(statisticalInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getId(name: string, options?: any): AxiosPromise<string> {
            return localVarFp.getId(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPopUpInfo(userid: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getPopUpInfo(userid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable(statisticalInfo: StatisticalInfo, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getTable(statisticalInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticalInfoControllerApi - object-oriented interface
 * @export
 * @class StatisticalInfoControllerApi
 * @extends {BaseAPI}
 */
export class StatisticalInfoControllerApi extends BaseAPI {
    /**
     * 
     * @param {StatisticalInfo} statisticalInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getGraph(statisticalInfo: StatisticalInfo, options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getGraph(statisticalInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getId(name: string, options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getId(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getInfo(options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getPopUpInfo(userid: string, options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getPopUpInfo(userid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StatisticalInfo} statisticalInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getTable(statisticalInfo: StatisticalInfo, options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getTable(statisticalInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderatorAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/mod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderatorAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderatorAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAccess(options?: any): AxiosPromise<string> {
            return localVarFp.adminAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allAccess(options?: any): AxiosPromise<string> {
            return localVarFp.allAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderatorAccess(options?: any): AxiosPromise<string> {
            return localVarFp.moderatorAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccess(options?: any): AxiosPromise<string> {
            return localVarFp.userAccess(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public adminAccess(options?: any) {
        return TestControllerApiFp(this.configuration).adminAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public allAccess(options?: any) {
        return TestControllerApiFp(this.configuration).allAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public moderatorAccess(options?: any) {
        return TestControllerApiFp(this.configuration).moderatorAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public userAccess(options?: any) {
        return TestControllerApiFp(this.configuration).userAccess(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThresholdControllerApi - axios parameter creator
 * @export
 */
export const ThresholdControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<Threshold>} threshold 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial: async (threshold: Array<Threshold>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'threshold' is not null or undefined
            assertParamExists('createTutorial', 'threshold', threshold)
            const localVarPath = `/api/threshold/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(threshold, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList: async (title?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/threshold/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThresholdControllerApi - functional programming interface
 * @export
 */
export const ThresholdControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThresholdControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<Threshold>} threshold 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial(threshold: Array<Threshold>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Threshold>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial(threshold, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholdList(title?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Threshold>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholdList(title, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ThresholdControllerApi - factory interface
 * @export
 */
export const ThresholdControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThresholdControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<Threshold>} threshold 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial(threshold: Array<Threshold>, options?: any): AxiosPromise<Threshold> {
            return localVarFp.createTutorial(threshold, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList(title?: string, options?: any): AxiosPromise<Array<Threshold>> {
            return localVarFp.getThresholdList(title, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThresholdControllerApi - object-oriented interface
 * @export
 * @class ThresholdControllerApi
 * @extends {BaseAPI}
 */
export class ThresholdControllerApi extends BaseAPI {
    /**
     * 
     * @param {Array<Threshold>} threshold 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThresholdControllerApi
     */
    public createTutorial(threshold: Array<Threshold>, options?: any) {
        return ThresholdControllerApiFp(this.configuration).createTutorial(threshold, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThresholdControllerApi
     */
    public getThresholdList(title?: string, options?: any) {
        return ThresholdControllerApiFp(this.configuration).getThresholdList(title, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserManagementControllerApi - axios parameter creator
 * @export
 */
export const UserManagementControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/api/user/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getBnList', 'data', data)
            const localVarPath = `/api/user/bnList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/divsList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/api/user/info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLog: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/getUserLog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Usercd} usercd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (usercd: Usercd, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'usercd' is not null or undefined
            assertParamExists('updateUser', 'usercd', usercd)
            const localVarPath = `/api/user/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usercd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementControllerApi - functional programming interface
 * @export
 */
export const UserManagementControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Usercd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBnList(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBnList(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmncdList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmncdList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDivList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDivList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Usercd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserLog(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserLog(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Usercd} usercd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(usercd: Usercd, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Usercd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(usercd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserManagementControllerApi - factory interface
 * @export
 */
export const UserManagementControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<Usercd> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList(data: string, options?: any): AxiosPromise<Array<TreeInfo>> {
            return localVarFp.getBnList(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList(page?: number, pageSize?: number, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getCmncdList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getDivList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<Usercd> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserLog(page?: number, pageSize?: number, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getUserLog(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Usercd} usercd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(usercd: Usercd, options?: any): AxiosPromise<Usercd> {
            return localVarFp.updateUser(usercd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementControllerApi - object-oriented interface
 * @export
 * @class UserManagementControllerApi
 * @extends {BaseAPI}
 */
export class UserManagementControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public deleteUser(id: string, options?: any) {
        return UserManagementControllerApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public getBnList(data: string, options?: any) {
        return UserManagementControllerApiFp(this.configuration).getBnList(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public getCmncdList(page?: number, pageSize?: number, options?: any) {
        return UserManagementControllerApiFp(this.configuration).getCmncdList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public getDivList(options?: any) {
        return UserManagementControllerApiFp(this.configuration).getDivList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public getUser(id: string, options?: any) {
        return UserManagementControllerApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public getUserLog(page?: number, pageSize?: number, options?: any) {
        return UserManagementControllerApiFp(this.configuration).getUserLog(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Usercd} usercd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public updateUser(usercd: Usercd, options?: any) {
        return UserManagementControllerApiFp(this.configuration).updateUser(usercd, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VehicleStatisticsControllerApi - axios parameter creator
 * @export
 */
export const VehicleStatisticsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultBookmark: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('defaultBookmark', 'id', id)
            const localVarPath = `/api/vehicleStatistics/allBookmarkForDefault/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sdaid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRecentFile: async (sdaid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sdaid' is not null or undefined
            assertParamExists('findRecentFile', 'sdaid', sdaid)
            const localVarPath = `/api/vehicleStatistics/findRecentFile/{sdaid}`
                .replace(`{${"sdaid"}}`, encodeURIComponent(String(sdaid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicleData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} grpid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark: async (id: string, grpid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBookmark', 'id', id)
            // verify required parameter 'grpid' is not null or undefined
            assertParamExists('getBookmark', 'grpid', grpid)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getBookmark/{id}/{grpid}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"grpid"}}`, encodeURIComponent(String(grpid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<object>} param1 
         * @param {Array<object>} param2 
         * @param {Array<object>} param3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartData: async (param1: Array<object>, param2: Array<object>, param3: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'param1' is not null or undefined
            assertParamExists('getChartData', 'param1', param1)
            // verify required parameter 'param2' is not null or undefined
            assertParamExists('getChartData', 'param2', param2)
            // verify required parameter 'param3' is not null or undefined
            assertParamExists('getChartData', 'param3', param3)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getChartData/{param1}/{param2}/{param3}`
                .replace(`{${"param1"}}`, encodeURIComponent(String(param1)))
                .replace(`{${"param2"}}`, encodeURIComponent(String(param2)))
                .replace(`{${"param3"}}`, encodeURIComponent(String(param3)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<object>} params1 
         * @param {Array<object>} params2 
         * @param {Array<object>} params3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDtctsdaData: async (params1: Array<object>, params2: Array<object>, params3: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'params1' is not null or undefined
            assertParamExists('getDtctsdaData', 'params1', params1)
            // verify required parameter 'params2' is not null or undefined
            assertParamExists('getDtctsdaData', 'params2', params2)
            // verify required parameter 'params3' is not null or undefined
            assertParamExists('getDtctsdaData', 'params3', params3)
            const localVarPath = `/api/vehicleStatistics/getDtctsdaData/{params1}/{params2}/{params3}`
                .replace(`{${"params1"}}`, encodeURIComponent(String(params1)))
                .replace(`{${"params2"}}`, encodeURIComponent(String(params2)))
                .replace(`{${"params3"}}`, encodeURIComponent(String(params3)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEachData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEachData', 'id', id)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileWithId: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFileWithId', 'id', id)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getFile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getForBtn1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getForBtn2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<UserSnsr>} userSnsr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertBookmark: async (userSnsr: Array<UserSnsr>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSnsr' is not null or undefined
            assertParamExists('insertBookmark', 'userSnsr', userSnsr)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/insertBookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSnsr, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehicleStatisticsControllerApi - functional programming interface
 * @export
 */
export const VehicleStatisticsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VehicleStatisticsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultBookmark(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultBookmark(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sdaid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRecentFile(sdaid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRecentFile(sdaid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVehicleData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVehicleData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} grpid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmark(id: string, grpid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSnsr>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmark(id, grpid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<object>} param1 
         * @param {Array<object>} param2 
         * @param {Array<object>} param3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChartData(param1: Array<object>, param2: Array<object>, param3: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SdaData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChartData(param1, param2, param3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<object>} params1 
         * @param {Array<object>} params2 
         * @param {Array<object>} params3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDtctsdaData(params1: Array<object>, params2: Array<object>, params3: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SdaDataWithDtctsda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDtctsdaData(params1, params2, params3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEachData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sda>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEachData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileWithId(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SdaData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileWithId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForButton1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForButton1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForButton2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForButton2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<UserSnsr>} userSnsr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertBookmark(userSnsr: Array<UserSnsr>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSnsr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertBookmark(userSnsr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VehicleStatisticsControllerApi - factory interface
 * @export
 */
export const VehicleStatisticsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VehicleStatisticsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultBookmark(id: string, options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.defaultBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sdaid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRecentFile(sdaid: string, options?: any): AxiosPromise<string> {
            return localVarFp.findRecentFile(sdaid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicleData(options?: any): AxiosPromise<Array<Sda>> {
            return localVarFp.getAllVehicleData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} grpid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark(id: string, grpid: string, options?: any): AxiosPromise<Array<UserSnsr>> {
            return localVarFp.getBookmark(id, grpid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<object>} param1 
         * @param {Array<object>} param2 
         * @param {Array<object>} param3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartData(param1: Array<object>, param2: Array<object>, param3: Array<object>, options?: any): AxiosPromise<Array<SdaData>> {
            return localVarFp.getChartData(param1, param2, param3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<object>} params1 
         * @param {Array<object>} params2 
         * @param {Array<object>} params3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDtctsdaData(params1: Array<object>, params2: Array<object>, params3: Array<object>, options?: any): AxiosPromise<Array<SdaDataWithDtctsda>> {
            return localVarFp.getDtctsdaData(params1, params2, params3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEachData(id: string, options?: any): AxiosPromise<Sda> {
            return localVarFp.getEachData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileWithId(id: string, options?: any): AxiosPromise<Array<SdaData>> {
            return localVarFp.getFileWithId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton1(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getForButton1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton2(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getForButton2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<UserSnsr>} userSnsr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertBookmark(userSnsr: Array<UserSnsr>, options?: any): AxiosPromise<UserSnsr> {
            return localVarFp.insertBookmark(userSnsr, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VehicleStatisticsControllerApi - object-oriented interface
 * @export
 * @class VehicleStatisticsControllerApi
 * @extends {BaseAPI}
 */
export class VehicleStatisticsControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public defaultBookmark(id: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).defaultBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sdaid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public findRecentFile(sdaid: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).findRecentFile(sdaid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getAllVehicleData(options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getAllVehicleData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} grpid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getBookmark(id: string, grpid: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getBookmark(id, grpid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<object>} param1 
     * @param {Array<object>} param2 
     * @param {Array<object>} param3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getChartData(param1: Array<object>, param2: Array<object>, param3: Array<object>, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getChartData(param1, param2, param3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<object>} params1 
     * @param {Array<object>} params2 
     * @param {Array<object>} params3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getDtctsdaData(params1: Array<object>, params2: Array<object>, params3: Array<object>, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getDtctsdaData(params1, params2, params3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getEachData(id: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getEachData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getFileWithId(id: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getFileWithId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getForButton1(options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getForButton1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getForButton2(options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getForButton2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<UserSnsr>} userSnsr 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public insertBookmark(userSnsr: Array<UserSnsr>, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).insertBookmark(userSnsr, options).then((request) => request(this.axios, this.basePath));
    }
}



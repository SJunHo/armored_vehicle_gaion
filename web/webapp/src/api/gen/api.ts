/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AllTimeESStats
 */
export interface AllTimeESStats {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    byTrainNo?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    byCarNo?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    byType?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {Array<number>}
     * @memberof AllTimeESStats
     */
    weightingW?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AllTimeESStats
     */
    weightingB?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof AllTimeESStats
     */
    defectScoreGt0?: number;
    /**
     * 
     * @type {number}
     * @memberof AllTimeESStats
     */
    defectUserGt0?: number;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    defectMatrix?: { [key: string]: { [key: string]: number; }; };
}
/**
 * 
 * @export
 * @interface AuthRequestDTO
 */
export interface AuthRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AuthRequestDTO
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequestDTO
     */
    password: string;
}
/**
 * 
 * @export
 * @interface BaseAlgorithmPredictInput
 */
export interface BaseAlgorithmPredictInput {
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmPredictInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    modelName?: string;
    /**
     * 
     * @type {DataProvider}
     * @memberof BaseAlgorithmPredictInput
     */
    dataProvider?: DataProvider;
    /**
     * 
     * @type {DataInputOption}
     * @memberof BaseAlgorithmPredictInput
     */
    dataInputOption?: DataInputOption;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    listFieldsForPredict?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    dbDocIds?: Array<string>;
    /**
     * 
     * @type {FileInput}
     * @memberof BaseAlgorithmPredictInput
     */
    fileInput?: FileInput;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmPredictInput
     */
    threshold?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmPredictInput
     */
    dimensionalityReduction?: boolean;
}
/**
 * 
 * @export
 * @interface BaseAlgorithmTrainInput
 */
export interface BaseAlgorithmTrainInput {
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmTrainInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    trainingESIndex?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numClasses?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numTrees?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    featureSubsetStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    impurity?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxDepths?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxBins?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    bin?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmTrainInput
     */
    filterOutFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    modelName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmTrainInput
     */
    featuresSelectionEnableFlg?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    fraction?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxIter?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    layers?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    blockSize?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    lambda?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    regParam?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmTrainInput
     */
    intercept?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    elasticNetMixing?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    lseed?: number;
}
/**
 * 
 * @export
 * @interface ClassificationResponse
 */
export interface ClassificationResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof ClassificationResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof ClassificationResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ClassificationResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictedFeatureLine?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterResponse
 */
export interface ClusterResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof ClusterResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof ClusterResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof ClusterResponse
     */
    centers?: Array<Array<number>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ClusterResponse
     */
    totalPointsEachCluster?: { [key: string]: number; };
    /**
     * 
     * @type {Array<number>}
     * @memberof ClusterResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    tagLabels?: Array<string>;
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof ClusterResponse
     */
    actual?: Array<{ [key: string]: object; }>;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    processed?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterTrainInput
 */
export interface ClusterTrainInput {
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterTrainInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    trainingESIndex?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numClasses?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numTrees?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    featureSubsetStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    impurity?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxDepths?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxBins?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    bin?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterTrainInput
     */
    filterOutFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    modelName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    featuresSelectionEnableFlg?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    fraction?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxIter?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    layers?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    blockSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    lambda?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    regParam?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    intercept?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    elasticNetMixing?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numClusters?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numIterations?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    bootstrap?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxFeatures?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    lseed?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DataFormat {
    Basket = 'BASKET',
    Sparse = 'SPARSE',
    Dense = 'DENSE',
    Csv = 'CSV'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum DataInputOption {
    File = 'INPUT_FROM_FILE',
    Es = 'INPUT_FROM_ES',
    Db = 'INPUT_FROM_DB'
}

/**
 * 
 * @export
 * @interface DataLookup
 */
export interface DataLookup {
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    lookupName?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    updatedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    delimiter?: string;
    /**
     * 
     * @type {number}
     * @memberof DataLookup
     */
    indexOfLabeledField?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DataProvider {
    Ktme = 'KTME',
    Globiz = 'GLOBIZ'
}

/**
 * 
 * @export
 * @interface DbModelResponse
 */
export interface DbModelResponse {
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    algorithmResponseId?: number;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    modelName?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DbModelResponse
     */
    checked?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DbModelResponse
     */
    coefficients?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    rootMeanSquaredError?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    r2?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DbModelResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof DbModelResponse
     */
    residuals?: Array<object>;
}
/**
 * 
 * @export
 * @interface ESDataUpdateInput
 */
export interface ESDataUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof ESDataUpdateInput
     */
    esId?: string;
    /**
     * 
     * @type {number}
     * @memberof ESDataUpdateInput
     */
    defectUser?: number;
    /**
     * 
     * @type {number}
     * @memberof ESDataUpdateInput
     */
    gdefectProb?: number;
    /**
     * 
     * @type {number}
     * @memberof ESDataUpdateInput
     */
    udefectProb?: number;
}
/**
 * 
 * @export
 * @interface FSResponse
 */
export interface FSResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof FSResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof FSResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    filteredFeatures?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    selectedFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    csv?: string;
    /**
     * 
     * @type {number}
     * @memberof FSResponse
     */
    numPrincipalComponents?: number;
}
/**
 * 
 * @export
 * @interface FileInput
 */
export interface FileInput {
    /**
     * 
     * @type {string}
     * @memberof FileInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInput
     */
    separator?: string;
}
/**
 * 
 * @export
 * @interface ImportESDataFromFileInput
 */
export interface ImportESDataFromFileInput {
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    fieldOpt?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    labeledIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    fieldValue?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    indexW?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    sourceName?: string;
    /**
     * 
     * @type {DataFormat}
     * @memberof ImportESDataFromFileInput
     */
    format?: DataFormat;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    delimiter?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportESDataFromFileInput
     */
    clearOldData?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ImportESDataFromFileInput
     */
    listColumns?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    indexOfColumnID?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    indexOfColumnCategory?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    numberFeatures?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    columnPrimaryKey?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportESDataFromFileInput
     */
    listUploadedFiles?: Array<string>;
}
/**
 * 
 * @export
 * @interface PageRailSensorData
 */
export interface PageRailSensorData {
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    size?: number;
    /**
     * 
     * @type {Array<RailSensorData>}
     * @memberof PageRailSensorData
     */
    content?: Array<RailSensorData>;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageRailSensorData
     */
    sort?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof PageRailSensorData
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageRailSensorData
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageRailSensorData
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageRailSensorData
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}
/**
 * 
 * @export
 * @interface RailSensorData
 */
export interface RailSensorData {
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    round?: number;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    esId?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    trainNo?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    carNo?: number;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    wb?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    lr?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    ns?: string;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    oneTwo?: number;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    measurementTime?: string;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    velocity?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    velocityC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    airTemp?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    airTempC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadcell?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadcellC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    vib?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    vibV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    vibC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    temp?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    tempV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    tempC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    sound?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    soundV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    soundC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    ae?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    aeV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    aeC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    totalValue?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    totalCount?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    atv?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    atc?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    defectProb?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    severity?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    recSeverity?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    remainingLifetime?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    defectScore?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    defectUser?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    entrySpeed?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    weightingStateEquation?: number;
}
/**
 * 
 * @export
 * @interface RandomForestClassificationResponse
 */
export interface RandomForestClassificationResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof RandomForestClassificationResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof RandomForestClassificationResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RandomForestClassificationResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictedFeatureLine?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    decisionTree?: string;
}
/**
 * 
 * @export
 * @interface RegressionResponse
 */
export interface RegressionResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof RegressionResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof RegressionResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictedFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof RegressionResponse
     */
    coefficients?: Array<number>;
    /**
     * 
     * @type {Array<object>}
     * @memberof RegressionResponse
     */
    residuals?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof RegressionResponse
     */
    rootMeanSquaredError?: number;
    /**
     * 
     * @type {number}
     * @memberof RegressionResponse
     */
    r2?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ResponseStatus {
    None = 'NONE',
    Initialized = 'INITIALIZED',
    Success = 'SUCCESS',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ResponseType {
    Message = 'MESSAGE',
    ObjectData = 'OBJECT_DATA'
}

/**
 * 
 * @export
 * @interface SVMClassificationResponse
 */
export interface SVMClassificationResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof SVMClassificationResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof SVMClassificationResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof SVMClassificationResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof SVMClassificationResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SVMClassificationResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SVMClassificationResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof SVMClassificationResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SVMClassificationResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof SVMClassificationResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SVMClassificationResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof SVMClassificationResponse
     */
    predictedFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof SVMClassificationResponse
     */
    rocByThresholds?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    areaUnderRoc?: number;
    /**
     * 
     * @type {number}
     * @memberof SVMClassificationResponse
     */
    areaUnderPrecisionRecallCurve?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof SVMClassificationResponse
     */
    thresholds?: Array<number>;
    /**
     * 
     * @type {Array<object>}
     * @memberof SVMClassificationResponse
     */
    precisionByThreshold?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof SVMClassificationResponse
     */
    recallByThreshold?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof SVMClassificationResponse
     */
    f1ScoreByThreshold?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof SVMClassificationResponse
     */
    f2ScoreByThreshold?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof SVMClassificationResponse
     */
    precisionRecallCurve?: Array<object>;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateDataLookupInput
 */
export interface UpdateDataLookupInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    lookupName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    delimiter?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateDataLookupInput
     */
    indexOfLabeledField?: number;
}
/**
 * 
 * @export
 * @interface UpdateModelInput
 */
export interface UpdateModelInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateModelInput
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateModelInput
     */
    checked?: boolean;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin: async (authRequestDTO: AuthRequestDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRequestDTO' is not null or undefined
            assertParamExists('userLogin', 'authRequestDTO', authRequestDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogin(authRequestDTO: AuthRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogin(authRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(authRequestDTO: AuthRequestDTO, options?: any): AxiosPromise<string> {
            return localVarFp.userLogin(authRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @param {AuthRequestDTO} authRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public userLogin(authRequestDTO: AuthRequestDTO, options?: any) {
        return AuthControllerApiFp(this.configuration).userLogin(authRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetControllerApi - axios parameter creator
 * @export
 */
export const DatasetControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allTimeStats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/stats/all-times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsDailyInLast30Days: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/stats/month-daily-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsMonthlyLast6Months: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/stats/6-months-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataLookup: async (updateDataLookupInput: UpdateDataLookupInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDataLookupInput' is not null or undefined
            assertParamExists('createDataLookup', 'updateDataLookupInput', updateDataLookupInput)
            const localVarPath = `/api/data-lookup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataLookupInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataLookup: async (lookupName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lookupName' is not null or undefined
            assertParamExists('deleteDataLookup', 'lookupName', lookupName)
            const localVarPath = `/api/data-lookup/{lookupName}`
                .replace(`{${"lookupName"}}`, encodeURIComponent(String(lookupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} wb 
         * @param {string} [trainNo] 
         * @param {string} [carNo] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [severity] 
         * @param {boolean} [hasDefectScore] 
         * @param {number} [hasDefectUser] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConditionData: async (wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wb' is not null or undefined
            assertParamExists('getAllConditionData', 'wb', wb)
            const localVarPath = `/api/data/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (wb !== undefined) {
                localVarQueryParameter['wb'] = wb;
            }

            if (trainNo !== undefined) {
                localVarQueryParameter['train-no'] = trainNo;
            }

            if (carNo !== undefined) {
                localVarQueryParameter['car-no'] = carNo;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (severity !== undefined) {
                localVarQueryParameter['severity'] = severity;
            }

            if (hasDefectScore !== undefined) {
                localVarQueryParameter['has_defect_score'] = hasDefectScore;
            }

            if (hasDefectUser !== undefined) {
                localVarQueryParameter['has_defect_user'] = hasDefectUser;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDataLookups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data-lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [trainNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarLists: async (trainNumber?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/trains-cars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (trainNumber !== undefined) {
                localVarQueryParameter['train-number'] = trainNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataToPredict: async (page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/predict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainLists: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/trains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportESDataFromFileInput} importESDataFromFileInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importESIndexFromCSV: async (importESDataFromFileInput: ImportESDataFromFileInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importESDataFromFileInput' is not null or undefined
            assertParamExists('importESIndexFromCSV', 'importESDataFromFileInput', importESDataFromFileInput)
            const localVarPath = `/api/data/import/csv-to-es`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importESDataFromFileInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataLookup: async (updateDataLookupInput: UpdateDataLookupInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDataLookupInput' is not null or undefined
            assertParamExists('updateDataLookup', 'updateDataLookupInput', updateDataLookupInput)
            const localVarPath = `/api/data-lookup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataLookupInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRailSensorData: async (eSDataUpdateInput: Array<ESDataUpdateInput>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eSDataUpdateInput' is not null or undefined
            assertParamExists('updateRailSensorData', 'eSDataUpdateInput', eSDataUpdateInput)
            const localVarPath = `/api/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eSDataUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDatasetFile: async (files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/upload-dataset-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetControllerApi - functional programming interface
 * @export
 */
export const DatasetControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allTimeStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTimeESStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allTimeStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countRecordsDailyInLast30Days(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countRecordsDailyInLast30Days(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countRecordsMonthlyLast6Months(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countRecordsMonthlyLast6Months(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataLookup(updateDataLookupInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataLookup(lookupName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataLookup(lookupName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} wb 
         * @param {string} [trainNo] 
         * @param {string} [carNo] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [severity] 
         * @param {boolean} [hasDefectScore] 
         * @param {number} [hasDefectUser] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllConditionData(wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRailSensorData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllConditionData(wb, trainNo, carNo, fromDate, toDate, severity, hasDefectScore, hasDefectUser, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDataLookups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataLookup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDataLookups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [trainNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarLists(trainNumber?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarLists(trainNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataToPredict(page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRailSensorData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataToPredict(page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainLists(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainLists(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportESDataFromFileInput} importESDataFromFileInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importESIndexFromCSV(importESDataFromFileInput: ImportESDataFromFileInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importESIndexFromCSV(importESDataFromFileInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataLookup(updateDataLookupInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRailSensorData(eSDataUpdateInput: Array<ESDataUpdateInput>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RailSensorData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRailSensorData(eSDataUpdateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDatasetFile(files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDatasetFile(files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetControllerApi - factory interface
 * @export
 */
export const DatasetControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allTimeStats(options?: any): AxiosPromise<AllTimeESStats> {
            return localVarFp.allTimeStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsDailyInLast30Days(options?: any): AxiosPromise<Array<number>> {
            return localVarFp.countRecordsDailyInLast30Days(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsMonthlyLast6Months(options?: any): AxiosPromise<Array<number>> {
            return localVarFp.countRecordsMonthlyLast6Months(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.createDataLookup(updateDataLookupInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataLookup(lookupName: string, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.deleteDataLookup(lookupName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} wb 
         * @param {string} [trainNo] 
         * @param {string} [carNo] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [severity] 
         * @param {boolean} [hasDefectScore] 
         * @param {number} [hasDefectUser] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConditionData(wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PageRailSensorData> {
            return localVarFp.getAllConditionData(wb, trainNo, carNo, fromDate, toDate, severity, hasDefectScore, hasDefectUser, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDataLookups(options?: any): AxiosPromise<Array<DataLookup>> {
            return localVarFp.getAllDataLookups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [trainNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarLists(trainNumber?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getCarLists(trainNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataToPredict(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PageRailSensorData> {
            return localVarFp.getDataToPredict(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainLists(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTrainLists(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportESDataFromFileInput} importESDataFromFileInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importESIndexFromCSV(importESDataFromFileInput: ImportESDataFromFileInput, options?: any): AxiosPromise<void> {
            return localVarFp.importESIndexFromCSV(importESDataFromFileInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.updateDataLookup(updateDataLookupInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRailSensorData(eSDataUpdateInput: Array<ESDataUpdateInput>, options?: any): AxiosPromise<Array<RailSensorData>> {
            return localVarFp.updateRailSensorData(eSDataUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDatasetFile(files?: Array<any>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.uploadDatasetFile(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetControllerApi - object-oriented interface
 * @export
 * @class DatasetControllerApi
 * @extends {BaseAPI}
 */
export class DatasetControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public allTimeStats(options?: any) {
        return DatasetControllerApiFp(this.configuration).allTimeStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public countRecordsDailyInLast30Days(options?: any) {
        return DatasetControllerApiFp(this.configuration).countRecordsDailyInLast30Days(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public countRecordsMonthlyLast6Months(options?: any) {
        return DatasetControllerApiFp(this.configuration).countRecordsMonthlyLast6Months(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDataLookupInput} updateDataLookupInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).createDataLookup(updateDataLookupInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lookupName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public deleteDataLookup(lookupName: string, options?: any) {
        return DatasetControllerApiFp(this.configuration).deleteDataLookup(lookupName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} wb 
     * @param {string} [trainNo] 
     * @param {string} [carNo] 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [severity] 
     * @param {boolean} [hasDefectScore] 
     * @param {number} [hasDefectUser] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getAllConditionData(wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetControllerApiFp(this.configuration).getAllConditionData(wb, trainNo, carNo, fromDate, toDate, severity, hasDefectScore, hasDefectUser, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getAllDataLookups(options?: any) {
        return DatasetControllerApiFp(this.configuration).getAllDataLookups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [trainNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getCarLists(trainNumber?: string, options?: any) {
        return DatasetControllerApiFp(this.configuration).getCarLists(trainNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getDataToPredict(page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetControllerApiFp(this.configuration).getDataToPredict(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getTrainLists(options?: any) {
        return DatasetControllerApiFp(this.configuration).getTrainLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportESDataFromFileInput} importESDataFromFileInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public importESIndexFromCSV(importESDataFromFileInput: ImportESDataFromFileInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).importESIndexFromCSV(importESDataFromFileInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDataLookupInput} updateDataLookupInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).updateDataLookup(updateDataLookupInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public updateRailSensorData(eSDataUpdateInput: Array<ESDataUpdateInput>, options?: any) {
        return DatasetControllerApiFp(this.configuration).updateRailSensorData(eSDataUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<any>} [files] Files to be uploaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public uploadDatasetFile(files?: Array<any>, options?: any) {
        return DatasetControllerApiFp(this.configuration).uploadDatasetFile(files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetDatabaseControllerApi - axios parameter creator
 * @export
 */
export const DatasetDatabaseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCSVFileAndImportDB: async (files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/database/upload-dataset-file-to-database`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetDatabaseControllerApi - functional programming interface
 * @export
 */
export const DatasetDatabaseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetDatabaseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCSVFileAndImportDB(files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCSVFileAndImportDB(files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetDatabaseControllerApi - factory interface
 * @export
 */
export const DatasetDatabaseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetDatabaseControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCSVFileAndImportDB(files?: Array<any>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.uploadCSVFileAndImportDB(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetDatabaseControllerApi - object-oriented interface
 * @export
 * @class DatasetDatabaseControllerApi
 * @extends {BaseAPI}
 */
export class DatasetDatabaseControllerApi extends BaseAPI {
    /**
     * 
     * @param {Array<any>} [files] Files to be uploaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public uploadCSVFileAndImportDB(files?: Array<any>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).uploadCSVFileAndImportDB(files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MlControllerApi - axios parameter creator
 * @export
 */
export const MlControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chiSquareFS: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('chiSquareFS', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/fs/chi-sq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (algorithm: string, algorithmResponseId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('deleteModel', 'algorithm', algorithm)
            // verify required parameter 'algorithmResponseId' is not null or undefined
            assertParamExists('deleteModel', 'algorithmResponseId', algorithmResponseId)
            const localVarPath = `/api/ml/{algorithm}/model/{algorithmResponseId}`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)))
                .replace(`{${"algorithmResponseId"}}`, encodeURIComponent(String(algorithmResponseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels: async (algorithm: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('getModels', 'algorithm', algorithm)
            const localVarPath = `/api/ml/{algorithm}/models`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataColumnList: async (index: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('getTrainingDataColumnList', 'index', index)
            const localVarPath = `/api/get-trainingData/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/get-trainingData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcaDimensionalityReduction: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('pcaDimensionalityReduction', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/fs/pca`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predict: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('predict', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('predict', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictCluster: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('predictCluster', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('predictCluster', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/cluster-predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainIsolationForest: async (clusterTrainInput: ClusterTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterTrainInput' is not null or undefined
            assertParamExists('trainIsolationForest', 'clusterTrainInput', clusterTrainInput)
            const localVarPath = `/api/train/if`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainKmean: async (clusterTrainInput: ClusterTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterTrainInput' is not null or undefined
            assertParamExists('trainKmean', 'clusterTrainInput', clusterTrainInput)
            const localVarPath = `/api/train/kmean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLassoRegression: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLassoRegression', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/lasso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinearRegression: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLinearRegression', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/linear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLr: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLr', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/lr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainMLP: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainMLP', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/mlp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainRfc: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainRfc', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/rfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainSVM: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainSVM', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/svm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel: async (algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('updateModel', 'algorithm', algorithm)
            // verify required parameter 'algorithmResponseId' is not null or undefined
            assertParamExists('updateModel', 'algorithmResponseId', algorithmResponseId)
            // verify required parameter 'updateModelInput' is not null or undefined
            assertParamExists('updateModel', 'updateModelInput', updateModelInput)
            const localVarPath = `/api/ml/{algorithm}/model/{algorithmResponseId}`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)))
                .replace(`{${"algorithmResponseId"}}`, encodeURIComponent(String(algorithmResponseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateModelInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MlControllerApi - functional programming interface
 * @export
 */
export const MlControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MlControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FSResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chiSquareFS(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(algorithm: string, algorithmResponseId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(algorithm, algorithmResponseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModels(algorithm: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DbModelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModels(algorithm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingDataColumnList(index: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingDataColumnList(index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingDataList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingDataList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FSResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcaDimensionalityReduction(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predict(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictCluster(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainIsolationForest(clusterTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainKmean(clusterTrainInput: ClusterTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainKmean(clusterTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLassoRegression(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLinearRegression(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLr(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainMLP(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RandomForestClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainRfc(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainSVM(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SVMClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainSVM(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DbModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModel(algorithm, algorithmResponseId, updateModelInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MlControllerApi - factory interface
 * @export
 */
export const MlControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MlControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<FSResponse> {
            return localVarFp.chiSquareFS(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(algorithm: string, algorithmResponseId: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteModel(algorithm, algorithmResponseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(algorithm: string, options?: any): AxiosPromise<Array<DbModelResponse>> {
            return localVarFp.getModels(algorithm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataColumnList(index: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTrainingDataColumnList(index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataList(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTrainingDataList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<FSResponse> {
            return localVarFp.pcaDimensionalityReduction(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.predict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.predictCluster(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.trainIsolationForest(clusterTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainKmean(clusterTrainInput: ClusterTrainInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.trainKmean(clusterTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.trainLassoRegression(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.trainLinearRegression(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainLr(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainMLP(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RandomForestClassificationResponse> {
            return localVarFp.trainRfc(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainSVM(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<SVMClassificationResponse> {
            return localVarFp.trainSVM(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any): AxiosPromise<DbModelResponse> {
            return localVarFp.updateModel(algorithm, algorithmResponseId, updateModelInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MlControllerApi - object-oriented interface
 * @export
 * @class MlControllerApi
 * @extends {BaseAPI}
 */
export class MlControllerApi extends BaseAPI {
    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).chiSquareFS(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {number} algorithmResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public deleteModel(algorithm: string, algorithmResponseId: number, options?: any) {
        return MlControllerApiFp(this.configuration).deleteModel(algorithm, algorithmResponseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getModels(algorithm: string, options?: any) {
        return MlControllerApiFp(this.configuration).getModels(algorithm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} index 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getTrainingDataColumnList(index: string, options?: any) {
        return MlControllerApiFp(this.configuration).getTrainingDataColumnList(index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getTrainingDataList(options?: any) {
        return MlControllerApiFp(this.configuration).getTrainingDataList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).pcaDimensionalityReduction(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public predict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).predict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).predictCluster(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClusterTrainInput} clusterTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainIsolationForest(clusterTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClusterTrainInput} clusterTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainKmean(clusterTrainInput: ClusterTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainKmean(clusterTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLassoRegression(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLinearRegression(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLr(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainMLP(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainRfc(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainSVM(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainSVM(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {number} algorithmResponseId 
     * @param {UpdateModelInput} updateModelInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any) {
        return MlControllerApiFp(this.configuration).updateModel(algorithm, algorithmResponseId, updateModelInput, options).then((request) => request(this.axios, this.basePath));
    }
}



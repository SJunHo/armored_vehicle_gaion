/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AllTimeESStats
 */
export interface AllTimeESStats {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    byTrainNo?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    byCarNo?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    byType?: { [key: string]: { [key: string]: number; }; };
    /**
     * 
     * @type {Array<number>}
     * @memberof AllTimeESStats
     */
    weightingW?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof AllTimeESStats
     */
    weightingB?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof AllTimeESStats
     */
    defectScoreGt0?: number;
    /**
     * 
     * @type {number}
     * @memberof AllTimeESStats
     */
    defectUserGt0?: number;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof AllTimeESStats
     */
    defectMatrix?: { [key: string]: { [key: string]: number; }; };
}
/**
 * 
 * @export
 * @interface AuthRequestDTO
 */
export interface AuthRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof AuthRequestDTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof AuthRequestDTO
     */
    password: string;
}
/**
 * 
 * @export
 * @interface BaseAlgorithmPredictInput
 */
export interface BaseAlgorithmPredictInput {
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmPredictInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    modelName?: string;
    /**
     * 
     * @type {DataProvider}
     * @memberof BaseAlgorithmPredictInput
     */
    dataProvider?: DataProvider;
    /**
     * 
     * @type {DataInputOption}
     * @memberof BaseAlgorithmPredictInput
     */
    dataInputOption?: DataInputOption;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    listFieldsForPredict?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmPredictInput
     */
    dbDocIds?: Array<string>;
    /**
     * 
     * @type {FileInput}
     * @memberof BaseAlgorithmPredictInput
     */
    fileInput?: FileInput;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmPredictInput
     */
    threshold?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmPredictInput
     */
    dimensionalityReduction?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmPredictInput
     */
    dataType?: string;
}
/**
 * 
 * @export
 * @interface BaseAlgorithmTrainInput
 */
export interface BaseAlgorithmTrainInput {
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmTrainInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    trainingESIndex?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    partType?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numClasses?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    numTrees?: number;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    featureSubsetStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    impurity?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxDepths?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxBins?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    bin?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof BaseAlgorithmTrainInput
     */
    filterOutFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    modelName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmTrainInput
     */
    featuresSelectionEnableFlg?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BaseAlgorithmTrainInput
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    fraction?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    maxIter?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    layers?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    blockSize?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    lambda?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    regParam?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BaseAlgorithmTrainInput
     */
    intercept?: boolean;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    elasticNetMixing?: number;
    /**
     * 
     * @type {number}
     * @memberof BaseAlgorithmTrainInput
     */
    lseed?: number;
}
/**
 * 
 * @export
 * @interface Board
 */
export interface Board {
    /**
     * 
     * @type {number}
     * @memberof Board
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Board
     */
    published?: boolean;
}
/**
 * 
 * @export
 * @interface ClassificationResponse
 */
export interface ClassificationResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof ClassificationResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof ClassificationResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClassificationResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof ClassificationResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof ClassificationResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    predictedFeatureLine?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClusterResponse
 */
export interface ClusterResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof ClusterResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof ClusterResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof ClusterResponse
     */
    centers?: Array<Array<number>>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ClusterResponse
     */
    totalPointsEachCluster?: { [key: string]: number; };
    /**
     * 
     * @type {Array<number>}
     * @memberof ClusterResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterResponse
     */
    tagLabels?: Array<string>;
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof ClusterResponse
     */
    actual?: Array<{ [key: string]: object; }>;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterResponse
     */
    processed?: boolean;
}
/**
 * 
 * @export
 * @interface ClusterTrainInput
 */
export interface ClusterTrainInput {
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numberPrincipalComponents?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterTrainInput
     */
    featureCols?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    trainingESIndex?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    partType?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numClasses?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numTrees?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    featureSubsetStrategy?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    impurity?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxDepths?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxBins?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    bin?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClusterTrainInput
     */
    filterOutFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    classCol?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    modelName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    featuresSelectionEnableFlg?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ClusterTrainInput
     */
    action?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    fraction?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    seed?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxIter?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    layers?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    blockSize?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    lambda?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    regParam?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    intercept?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    elasticNetMixing?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numClusters?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    numIterations?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ClusterTrainInput
     */
    bootstrap?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxFeatures?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    maxSamples?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterTrainInput
     */
    lseed?: number;
}
/**
 * 
 * @export
 * @interface Cmncd
 */
export interface Cmncd {
    /**
     * 
     * @type {number}
     * @memberof Cmncd
     */
    cmncdid?: number;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    _var?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    expln?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    usedvcd?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmncd
     */
    groupcode?: string;
}
/**
 * 
 * @export
 * @interface Cmpntsrplc
 */
export interface Cmpntsrplc {
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    grid?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    stdval?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    prdval?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    nmval?: string;
    /**
     * 
     * @type {string}
     * @memberof Cmpntsrplc
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @interface CmpntsrplcResponse
 */
export interface CmpntsrplcResponse {
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    grid?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    grnm?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    stdval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    prdval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    nmval?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof CmpntsrplcResponse
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DataFormat {
    Basket = 'BASKET',
    Sparse = 'SPARSE',
    Dense = 'DENSE',
    Csv = 'CSV'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum DataInputOption {
    File = 'INPUT_FROM_FILE',
    Es = 'INPUT_FROM_ES',
    Db = 'INPUT_FROM_DB'
}

/**
 * 
 * @export
 * @interface DataLookup
 */
export interface DataLookup {
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    lookupName?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    updatedTime?: string;
    /**
     * 
     * @type {string}
     * @memberof DataLookup
     */
    delimiter?: string;
    /**
     * 
     * @type {number}
     * @memberof DataLookup
     */
    indexOfLabeledField?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DataProvider {
    Ktme = 'KTME',
    Globiz = 'GLOBIZ'
}

/**
 * 
 * @export
 * @interface DbDataUpdateInput
 */
export interface DbDataUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof DbDataUpdateInput
     */
    dataType?: string;
    /**
     * 
     * @type {number}
     * @memberof DbDataUpdateInput
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DbDataUpdateInput
     */
    aiAlgorithm?: string;
    /**
     * 
     * @type {string}
     * @memberof DbDataUpdateInput
     */
    modelName?: string;
    /**
     * 
     * @type {number}
     * @memberof DbDataUpdateInput
     */
    aiPredict?: number;
}
/**
 * 
 * @export
 * @interface DbModelResponse
 */
export interface DbModelResponse {
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    algorithmResponseId?: number;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    partType?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    modelName?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    algorithmType?: string;
    /**
     * 
     * @type {string}
     * @memberof DbModelResponse
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DbModelResponse
     */
    checked?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof DbModelResponse
     */
    coefficients?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    rootMeanSquaredError?: number;
    /**
     * 
     * @type {number}
     * @memberof DbModelResponse
     */
    r2?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof DbModelResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {Array<object>}
     * @memberof DbModelResponse
     */
    residuals?: Array<object>;
}
/**
 * 
 * @export
 * @interface DriverAttitd
 */
export interface DriverAttitd {
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    daid?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    danm?: string;
    /**
     * 
     * @type {number}
     * @memberof DriverAttitd
     */
    bizlogic?: number;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    stdval?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    sign?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverAttitd
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ERole {
    User = 'ROLE_USER',
    Moderator = 'ROLE_MODERATOR',
    Admin = 'ROLE_ADMIN'
}

/**
 * 
 * @export
 * @interface ESDataUpdateInput
 */
export interface ESDataUpdateInput {
    /**
     * 
     * @type {string}
     * @memberof ESDataUpdateInput
     */
    esId?: string;
    /**
     * 
     * @type {number}
     * @memberof ESDataUpdateInput
     */
    defectUser?: number;
    /**
     * 
     * @type {number}
     * @memberof ESDataUpdateInput
     */
    gdefectProb?: number;
    /**
     * 
     * @type {number}
     * @memberof ESDataUpdateInput
     */
    udefectProb?: number;
}
/**
 * 
 * @export
 * @interface FSResponse
 */
export interface FSResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof FSResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof FSResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    filteredFeatures?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FSResponse
     */
    selectedFields?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FSResponse
     */
    csv?: string;
    /**
     * 
     * @type {number}
     * @memberof FSResponse
     */
    numPrincipalComponents?: number;
}
/**
 * 
 * @export
 * @interface FileInput
 */
export interface FileInput {
    /**
     * 
     * @type {string}
     * @memberof FileInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInput
     */
    separator?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum HttpStatus {
    _100Continue = '100 CONTINUE',
    _101SwitchingProtocols = '101 SWITCHING_PROTOCOLS',
    _102Processing = '102 PROCESSING',
    _103Checkpoint = '103 CHECKPOINT',
    _200Ok = '200 OK',
    _201Created = '201 CREATED',
    _202Accepted = '202 ACCEPTED',
    _203NonAuthoritativeInformation = '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent = '204 NO_CONTENT',
    _205ResetContent = '205 RESET_CONTENT',
    _206PartialContent = '206 PARTIAL_CONTENT',
    _207MultiStatus = '207 MULTI_STATUS',
    _208AlreadyReported = '208 ALREADY_REPORTED',
    _226ImUsed = '226 IM_USED',
    _300MultipleChoices = '300 MULTIPLE_CHOICES',
    _301MovedPermanently = '301 MOVED_PERMANENTLY',
    _302Found = '302 FOUND',
    _302MovedTemporarily = '302 MOVED_TEMPORARILY',
    _303SeeOther = '303 SEE_OTHER',
    _304NotModified = '304 NOT_MODIFIED',
    _305UseProxy = '305 USE_PROXY',
    _307TemporaryRedirect = '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect = '308 PERMANENT_REDIRECT',
    _400BadRequest = '400 BAD_REQUEST',
    _401Unauthorized = '401 UNAUTHORIZED',
    _402PaymentRequired = '402 PAYMENT_REQUIRED',
    _403Forbidden = '403 FORBIDDEN',
    _404NotFound = '404 NOT_FOUND',
    _405MethodNotAllowed = '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable = '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired = '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout = '408 REQUEST_TIMEOUT',
    _409Conflict = '409 CONFLICT',
    _410Gone = '410 GONE',
    _411LengthRequired = '411 LENGTH_REQUIRED',
    _412PreconditionFailed = '412 PRECONDITION_FAILED',
    _413PayloadTooLarge = '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge = '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong = '414 URI_TOO_LONG',
    _414RequestUriTooLong = '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType = '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable = '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed = '417 EXPECTATION_FAILED',
    _418IAmATeapot = '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource = '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure = '420 METHOD_FAILURE',
    _421DestinationLocked = '421 DESTINATION_LOCKED',
    _422UnprocessableEntity = '422 UNPROCESSABLE_ENTITY',
    _423Locked = '423 LOCKED',
    _424FailedDependency = '424 FAILED_DEPENDENCY',
    _425TooEarly = '425 TOO_EARLY',
    _426UpgradeRequired = '426 UPGRADE_REQUIRED',
    _428PreconditionRequired = '428 PRECONDITION_REQUIRED',
    _429TooManyRequests = '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge = '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons = '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError = '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented = '501 NOT_IMPLEMENTED',
    _502BadGateway = '502 BAD_GATEWAY',
    _503ServiceUnavailable = '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout = '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported = '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates = '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage = '507 INSUFFICIENT_STORAGE',
    _508LoopDetected = '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded = '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended = '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired = '511 NETWORK_AUTHENTICATION_REQUIRED'
}

/**
 * 
 * @export
 * @interface ImportESDataFromFileInput
 */
export interface ImportESDataFromFileInput {
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    fieldOpt?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    labeledIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    fieldValue?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    indexW?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    sourceName?: string;
    /**
     * 
     * @type {DataFormat}
     * @memberof ImportESDataFromFileInput
     */
    format?: DataFormat;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    fileName?: string;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    delimiter?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportESDataFromFileInput
     */
    clearOldData?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ImportESDataFromFileInput
     */
    listColumns?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    indexOfColumnID?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    indexOfColumnCategory?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportESDataFromFileInput
     */
    numberFeatures?: number;
    /**
     * 
     * @type {string}
     * @memberof ImportESDataFromFileInput
     */
    columnPrimaryKey?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportESDataFromFileInput
     */
    listUploadedFiles?: Array<string>;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface PageRailSensorData
 */
export interface PageRailSensorData {
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    size?: number;
    /**
     * 
     * @type {Array<RailSensorData>}
     * @memberof PageRailSensorData
     */
    content?: Array<RailSensorData>;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    number?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageRailSensorData
     */
    sort?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof PageRailSensorData
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageRailSensorData
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageRailSensorData
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageRailSensorData
     */
    pageable?: Pageable;
    /**
     * 
     * @type {boolean}
     * @memberof PageRailSensorData
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
}
/**
 * 
 * @export
 * @interface RailSensorData
 */
export interface RailSensorData {
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    round?: number;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    esId?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    trainNo?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    carNo?: number;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    wb?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    lr?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    ns?: string;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    oneTwo?: number;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof RailSensorData
     */
    measurementTime?: string;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    velocity?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    velocityC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    airTemp?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    airTempC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadcell?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadcellC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    vib?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    vibV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    vibC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    temp?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    tempV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    tempC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    sound?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    soundV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    soundC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    ae?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    aeV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    aeC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    totalValue?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    totalCount?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    atv?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    atc?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    defectProb?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    severity?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    recSeverity?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    remainingLifetime?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    defectScore?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    defectUser?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    entrySpeed?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadC?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    loadV?: number;
    /**
     * 
     * @type {number}
     * @memberof RailSensorData
     */
    weightingStateEquation?: number;
}
/**
 * 
 * @export
 * @interface RandomForestClassificationResponse
 */
export interface RandomForestClassificationResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof RandomForestClassificationResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof RandomForestClassificationResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RandomForestClassificationResponse
     */
    confusionMatrix?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    labels?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedFalsePositiveRate?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedFMeasure?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedPrecision?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedRecall?: number;
    /**
     * 
     * @type {number}
     * @memberof RandomForestClassificationResponse
     */
    weightedTruePositiveRate?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RandomForestClassificationResponse
     */
    predictedFeatureLine?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RandomForestClassificationResponse
     */
    decisionTree?: string;
}
/**
 * 
 * @export
 * @interface RegressionResponse
 */
export interface RegressionResponse {
    /**
     * 
     * @type {ResponseType}
     * @memberof RegressionResponse
     */
    type?: ResponseType;
    /**
     * 
     * @type {ResponseStatus}
     * @memberof RegressionResponse
     */
    status?: ResponseStatus;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    idCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    listFeatures?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RegressionResponse
     */
    classCol?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictionInfo?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictedActualFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegressionResponse
     */
    predictedFeatureLine?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof RegressionResponse
     */
    coefficients?: Array<number>;
    /**
     * 
     * @type {Array<object>}
     * @memberof RegressionResponse
     */
    residuals?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof RegressionResponse
     */
    rootMeanSquaredError?: number;
    /**
     * 
     * @type {number}
     * @memberof RegressionResponse
     */
    r2?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ResponseStatus {
    None = 'NONE',
    Initialized = 'INITIALIZED',
    Success = 'SUCCESS',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ResponseType {
    Message = 'MESSAGE',
    ObjectData = 'OBJECT_DATA'
}

/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    id?: number;
    /**
     * 
     * @type {ERole}
     * @memberof Role
     */
    name?: ERole;
}
/**
 * 
 * @export
 * @interface Sda
 */
export interface Sda {
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sdanm?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    divs?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    brgd?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    bn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    rgstno?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    mfdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    rgstdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    acqdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    sdatype?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    divscode?: string;
    /**
     * 
     * @type {string}
     * @memberof Sda
     */
    brgdbncode?: string;
}
/**
 * 
 * @export
 * @interface SdaData
 */
export interface SdaData {
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    filenm?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    operdate?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    opertime?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    dttime?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    time?: string;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engsta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    reqendtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engload?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    sdhspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    accpedal?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    cooltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    enggastemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engwarning?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engoilprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engoilsta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engheat?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    enggov?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    industfil?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    outtemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    cooloil?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    coollant?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fueltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transoutspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transinspd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    engoverctlmd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    overreqtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    autotrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    detailtrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    reqtrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    currttrans?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    emertransmd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transoiltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    transoilheat?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fanmd?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fanairtemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fancoolanttemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fanvvalduty?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    parksta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_break?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdbreak?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdcho?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    reqretdtok?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    retdoiltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    airmaster?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    breakoil?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    frtbreakprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    backbreakprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    airtankr?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    airtankl?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    frtairtand?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    fuel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    voltage?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    battsta?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    absoper?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    absyaji?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    abswarning?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2avgspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2lspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2rspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3lspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3rspeed?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_1lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    dmotion?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_4lock?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    shiftmode?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowswitch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    norswitch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    highswitch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    pneumatic?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_8by8?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_6by6?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_1wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_2wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_3wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    get_4wheel?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    promotewater?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lockrelease?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoilprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoiltemp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoilqty?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    lowoilfilter?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    winchclutch?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    backdooropen?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    overprs?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    overprseqp?: number;
    /**
     * 
     * @type {number}
     * @memberof SdaData
     */
    ctisairprs?: number;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    pbit?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaData
     */
    tableName?: string;
}
/**
 * 
 * @export
 * @interface SdaDataWithDtctsda
 */
export interface SdaDataWithDtctsda {
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    filenm?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    dttime?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof SdaDataWithDtctsda
     */
    snsrvle?: string;
}
/**
 * 
 * @export
 * @interface SearchRequest
 */
export interface SearchRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    sdaid?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    divscode?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchRequest
     */
    brgdbncode?: string;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchRequest
     */
    size?: number;
}
/**
 * 
 * @export
 * @interface SensorBearing
 */
export interface SensorBearing {
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearing
     */
    carId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearing
     */
    operateDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearing
     */
    operateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearing
     */
    operateDateTime?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    timeIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    aiPredict?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearing
     */
    aiAlgorithm?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorBearing
     */
    aiModel?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbvOverallRMS?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv1x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv6912bpfo?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv6912bpfi?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv6912bsf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv6912ftf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32924bpfo?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32924bpfi?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32924bsf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32924ftf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32922bpfo?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32922bpfi?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32922bsf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbv32922ftf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbvCrestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbvDemodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbsFault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbsFault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    lbtTemperature?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbvOverallRMS?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv1x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv6912bpfo?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv6912bpfi?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv6912bsf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv6912ftf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32924bpfo?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32924bpfi?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32924bsf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32924ftf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32922bpfo?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32922bpfi?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32922bsf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbv32922ftf?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbvCrestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbvDemodulation?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbsFault1?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbsFault2?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    rbtTemperature?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorBearing
     */
    filenm?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorBearing
     */
    wrpm?: number;
}
/**
 * 
 * @export
 * @interface SensorEngine
 */
export interface SensorEngine {
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorEngine
     */
    carId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngine
     */
    operateDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngine
     */
    operateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngine
     */
    operateDateTime?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    timeIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    aiPredict?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorEngine
     */
    aiAlgorithm?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorEngine
     */
    aiModel?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    wrpm?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    evOverallRms?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    ev12x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    ev1x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    evCrestfactor?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    ach?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    acv?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    aca?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    la?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorEngine
     */
    lo?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorEngine
     */
    filenm?: string;
}
/**
 * 
 * @export
 * @interface SensorGearbox
 */
export interface SensorGearbox {
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorGearbox
     */
    carId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearbox
     */
    operateDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearbox
     */
    operateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearbox
     */
    operateDateTime?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    timeIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    aiPredict?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorGearbox
     */
    aiAlgorithm?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorGearbox
     */
    aiModel?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    wrpm?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    gvOverallRms?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    gvWheel1x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    gvWheel2x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    gvPinion1x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    gvPinion2x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    gvGmf1x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorGearbox
     */
    gvGmf2x?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorGearbox
     */
    filenm?: string;
}
/**
 * 
 * @export
 * @interface SensorTempLife
 */
export interface SensorTempLife {
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorTempLife
     */
    aiAlgorithm?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorTempLife
     */
    aiModel?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    cpuUtil?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    diskAccesses?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    diskBlocks?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    diskUtil?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    instRetired?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    lastLevel?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    memoryBus?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    coreCycle?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorTempLife
     */
    time?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorTempLife
     */
    filenm?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorTempLife
     */
    aiPredict?: number;
}
/**
 * 
 * @export
 * @interface SensorWheel
 */
export interface SensorWheel {
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    idx?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorWheel
     */
    carId?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheel
     */
    operateDate?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheel
     */
    operateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheel
     */
    operateDateTime?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    timeIndex?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    aiPredict?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorWheel
     */
    aiAlgorithm?: string;
    /**
     * 
     * @type {string}
     * @memberof SensorWheel
     */
    aiModel?: string;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    wrpm?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    lwv2x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    lwv3x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    lwsFault3?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    rwv2x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    rwv3x?: number;
    /**
     * 
     * @type {number}
     * @memberof SensorWheel
     */
    rwsFault3?: number;
    /**
     * 
     * @type {string}
     * @memberof SensorWheel
     */
    filenm?: string;
}
/**
 * 
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    usrth?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    phonenum?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    mltrank?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    mltnum?: string;
    /**
     * 
     * @type {string}
     * @memberof SignupRequest
     */
    mltunit?: string;
}
/**
 * 
 * @export
 * @interface Snsr
 */
export interface Snsr {
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrnm?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrtype?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrdiv?: string;
    /**
     * 
     * @type {string}
     * @memberof Snsr
     */
    snsrunit?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface StatisticalInfo
 */
export interface StatisticalInfo {
    /**
     * 
     * @type {string}
     * @memberof StatisticalInfo
     */
    level?: string;
    /**
     * 
     * @type {string}
     * @memberof StatisticalInfo
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof StatisticalInfo
     */
    date?: string;
}
/**
 * 
 * @export
 * @interface Threshold
 */
export interface Threshold {
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    snsrid?: string;
    /**
     * 
     * @type {number}
     * @memberof Threshold
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof Threshold
     */
    min?: number;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof Threshold
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @interface ThresholdResponse
 */
export interface ThresholdResponse {
    /**
     * 
     * @type {string}
     * @memberof ThresholdResponse
     */
    snsrid?: string;
    /**
     * 
     * @type {string}
     * @memberof ThresholdResponse
     */
    expln?: string;
    /**
     * 
     * @type {number}
     * @memberof ThresholdResponse
     */
    max?: number;
    /**
     * 
     * @type {number}
     * @memberof ThresholdResponse
     */
    min?: number;
    /**
     * 
     * @type {string}
     * @memberof ThresholdResponse
     */
    crtdt?: string;
    /**
     * 
     * @type {string}
     * @memberof ThresholdResponse
     */
    crtor?: string;
    /**
     * 
     * @type {string}
     * @memberof ThresholdResponse
     */
    mdfcdt?: string;
    /**
     * 
     * @type {string}
     * @memberof ThresholdResponse
     */
    mdfr?: string;
    /**
     * 
     * @type {string}
     * @memberof ThresholdResponse
     */
    usedvcd?: string;
}
/**
 * 
 * @export
 * @interface TreeInfo
 */
export interface TreeInfo {
    /**
     * 
     * @type {number}
     * @memberof TreeInfo
     */
    trinfoid?: number;
    /**
     * 
     * @type {string}
     * @memberof TreeInfo
     */
    trinfoname?: string;
    /**
     * 
     * @type {string}
     * @memberof TreeInfo
     */
    trinfocode?: string;
    /**
     * 
     * @type {number}
     * @memberof TreeInfo
     */
    trinfohead?: number;
}
/**
 * 
 * @export
 * @interface UpdateDataLookupInput
 */
export interface UpdateDataLookupInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    lookupName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    index?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDataLookupInput
     */
    delimiter?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateDataLookupInput
     */
    indexOfLabeledField?: number;
}
/**
 * 
 * @export
 * @interface UpdateModelInput
 */
export interface UpdateModelInput {
    /**
     * 
     * @type {string}
     * @memberof UpdateModelInput
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateModelInput
     */
    checked?: boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    usrth?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phonenum?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    mltrank?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    mltnum?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    mltunit?: string;
    /**
     * 
     * @type {Set<Role>}
     * @memberof User
     */
    roles?: Set<Role>;
}
/**
 * 
 * @export
 * @interface UserSnsr
 */
export interface UserSnsr {
    /**
     * 
     * @type {string}
     * @memberof UserSnsr
     */
    grpid?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSnsr
     */
    userid?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSnsr
     */
    snsrid?: string;
}

/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser: async (loginRequest: LoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authenticateUser', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (signupRequest: SignupRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signupRequest' is not null or undefined
            assertParamExists('registerUser', 'signupRequest', signupRequest)
            const localVarPath = `/api/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin: async (authRequestDTO: AuthRequestDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRequestDTO' is not null or undefined
            assertParamExists('userLogin', 'authRequestDTO', authRequestDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticateUser(loginRequest: LoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticateUser(loginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(signupRequest: SignupRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(signupRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userLogin(authRequestDTO: AuthRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userLogin(authRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateUser(loginRequest: LoginRequest, options?: any): AxiosPromise<object> {
            return localVarFp.authenticateUser(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignupRequest} signupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(signupRequest: SignupRequest, options?: any): AxiosPromise<object> {
            return localVarFp.registerUser(signupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthRequestDTO} authRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userLogin(authRequestDTO: AuthRequestDTO, options?: any): AxiosPromise<string> {
            return localVarFp.userLogin(authRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public authenticateUser(loginRequest: LoginRequest, options?: any) {
        return AuthControllerApiFp(this.configuration).authenticateUser(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignupRequest} signupRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public registerUser(signupRequest: SignupRequest, options?: any) {
        return AuthControllerApiFp(this.configuration).registerUser(signupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthRequestDTO} authRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public userLogin(authRequestDTO: AuthRequestDTO, options?: any) {
        return AuthControllerApiFp(this.configuration).userLogin(authRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BoardControllerApi - axios parameter creator
 * @export
 */
export const BoardControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial3: async (board: Board, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'board' is not null or undefined
            assertParamExists('createTutorial3', 'board', board)
            const localVarPath = `/api/board/tutorials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(board, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTutorials: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/board/tutorials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTutorial: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTutorial', 'id', id)
            const localVarPath = `/api/board/tutorials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByPublished: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/board/tutorials/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBoard: async (title?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/board/tutorials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTutorialById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTutorialById', 'id', id)
            const localVarPath = `/api/board/tutorials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTutorial: async (id: number, board: Board, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTutorial', 'id', id)
            // verify required parameter 'board' is not null or undefined
            assertParamExists('updateTutorial', 'board', board)
            const localVarPath = `/api/board/tutorials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(board, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardControllerApi - functional programming interface
 * @export
 */
export const BoardControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial3(board: Board, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial3(board, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllTutorials(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HttpStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllTutorials(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTutorial(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HttpStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTutorial(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByPublished(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Board>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByPublished(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllBoard(title?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Board>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBoard(title, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTutorialById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTutorialById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTutorial(id: number, board: Board, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTutorial(id, board, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BoardControllerApi - factory interface
 * @export
 */
export const BoardControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial3(board: Board, options?: any): AxiosPromise<Board> {
            return localVarFp.createTutorial3(board, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllTutorials(options?: any): AxiosPromise<HttpStatus> {
            return localVarFp.deleteAllTutorials(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTutorial(id: number, options?: any): AxiosPromise<HttpStatus> {
            return localVarFp.deleteTutorial(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByPublished(options?: any): AxiosPromise<Array<Board>> {
            return localVarFp.findByPublished(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllBoard(title?: string, options?: any): AxiosPromise<Array<Board>> {
            return localVarFp.getAllBoard(title, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTutorialById(id: number, options?: any): AxiosPromise<Board> {
            return localVarFp.getTutorialById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {Board} board 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTutorial(id: number, board: Board, options?: any): AxiosPromise<Board> {
            return localVarFp.updateTutorial(id, board, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardControllerApi - object-oriented interface
 * @export
 * @class BoardControllerApi
 * @extends {BaseAPI}
 */
export class BoardControllerApi extends BaseAPI {
    /**
     * 
     * @param {Board} board 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public createTutorial3(board: Board, options?: any) {
        return BoardControllerApiFp(this.configuration).createTutorial3(board, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public deleteAllTutorials(options?: any) {
        return BoardControllerApiFp(this.configuration).deleteAllTutorials(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public deleteTutorial(id: number, options?: any) {
        return BoardControllerApiFp(this.configuration).deleteTutorial(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public findByPublished(options?: any) {
        return BoardControllerApiFp(this.configuration).findByPublished(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public getAllBoard(title?: string, options?: any) {
        return BoardControllerApiFp(this.configuration).getAllBoard(title, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public getTutorialById(id: number, options?: any) {
        return BoardControllerApiFp(this.configuration).getTutorialById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {Board} board 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardControllerApi
     */
    public updateTutorial(id: number, board: Board, options?: any) {
        return BoardControllerApiFp(this.configuration).updateTutorial(id, board, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CimControllerApi - axios parameter creator
 * @export
 */
export const CimControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmncd: async (cmncd: Cmncd, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmncd' is not null or undefined
            assertParamExists('createCmncd', 'cmncd', cmncd)
            const localVarPath = `/api/cim/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmncd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmncd: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCmncd', 'id', id)
            const localVarPath = `/api/cim/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncd: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCmncd', 'id', id)
            const localVarPath = `/api/cim/info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList1: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cim/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmncd: async (cmncd: Cmncd, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmncd' is not null or undefined
            assertParamExists('updateCmncd', 'cmncd', cmncd)
            const localVarPath = `/api/cim/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmncd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CimControllerApi - functional programming interface
 * @export
 */
export const CimControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CimControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCmncd(cmncd: Cmncd, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCmncd(cmncd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCmncd(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCmncd(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmncd(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmncd(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmncdList1(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmncdList1(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCmncd(cmncd: Cmncd, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCmncd(cmncd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CimControllerApi - factory interface
 * @export
 */
export const CimControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CimControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCmncd(cmncd: Cmncd, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.createCmncd(cmncd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCmncd(id: number, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.deleteCmncd(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncd(id: number, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.getCmncd(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList1(page?: number, pageSize?: number, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getCmncdList1(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Cmncd} cmncd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCmncd(cmncd: Cmncd, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.updateCmncd(cmncd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CimControllerApi - object-oriented interface
 * @export
 * @class CimControllerApi
 * @extends {BaseAPI}
 */
export class CimControllerApi extends BaseAPI {
    /**
     * 
     * @param {Cmncd} cmncd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public createCmncd(cmncd: Cmncd, options?: any) {
        return CimControllerApiFp(this.configuration).createCmncd(cmncd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public deleteCmncd(id: number, options?: any) {
        return CimControllerApiFp(this.configuration).deleteCmncd(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public getCmncd(id: number, options?: any) {
        return CimControllerApiFp(this.configuration).getCmncd(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public getCmncdList1(page?: number, pageSize?: number, options?: any) {
        return CimControllerApiFp(this.configuration).getCmncdList1(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Cmncd} cmncd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CimControllerApi
     */
    public updateCmncd(cmncd: Cmncd, options?: any) {
        return CimControllerApiFp(this.configuration).updateCmncd(cmncd, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetControllerApi - axios parameter creator
 * @export
 */
export const DatasetControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allTimeStats: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/stats/all-times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsDailyInLast30Days: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/stats/month-daily-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsMonthlyLast6Months: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/stats/6-months-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataLookup: async (updateDataLookupInput: UpdateDataLookupInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDataLookupInput' is not null or undefined
            assertParamExists('createDataLookup', 'updateDataLookupInput', updateDataLookupInput)
            const localVarPath = `/api/data-lookup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataLookupInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataLookup: async (lookupName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'lookupName' is not null or undefined
            assertParamExists('deleteDataLookup', 'lookupName', lookupName)
            const localVarPath = `/api/data-lookup/{lookupName}`
                .replace(`{${"lookupName"}}`, encodeURIComponent(String(lookupName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} wb 
         * @param {string} [trainNo] 
         * @param {string} [carNo] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [severity] 
         * @param {boolean} [hasDefectScore] 
         * @param {number} [hasDefectUser] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConditionData: async (wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'wb' is not null or undefined
            assertParamExists('getAllConditionData', 'wb', wb)
            const localVarPath = `/api/data/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (wb !== undefined) {
                localVarQueryParameter['wb'] = wb;
            }

            if (trainNo !== undefined) {
                localVarQueryParameter['train-no'] = trainNo;
            }

            if (carNo !== undefined) {
                localVarQueryParameter['car-no'] = carNo;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['from-date'] = (fromDate as any instanceof Date) ?
                    (fromDate as any).toISOString() :
                    fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to-date'] = (toDate as any instanceof Date) ?
                    (toDate as any).toISOString() :
                    toDate;
            }

            if (severity !== undefined) {
                localVarQueryParameter['severity'] = severity;
            }

            if (hasDefectScore !== undefined) {
                localVarQueryParameter['has_defect_score'] = hasDefectScore;
            }

            if (hasDefectUser !== undefined) {
                localVarQueryParameter['has_defect_user'] = hasDefectUser;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDataLookups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data-lookup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [trainNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarLists: async (trainNumber?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/trains-cars`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (trainNumber !== undefined) {
                localVarQueryParameter['train-number'] = trainNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataToPredict: async (page?: number, size?: number, sort?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/predict`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainLists: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/trains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportESDataFromFileInput} importESDataFromFileInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importESIndexFromCSV: async (importESDataFromFileInput: ImportESDataFromFileInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importESDataFromFileInput' is not null or undefined
            assertParamExists('importESIndexFromCSV', 'importESDataFromFileInput', importESDataFromFileInput)
            const localVarPath = `/api/data/import/csv-to-es`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importESDataFromFileInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataLookup: async (updateDataLookupInput: UpdateDataLookupInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDataLookupInput' is not null or undefined
            assertParamExists('updateDataLookup', 'updateDataLookupInput', updateDataLookupInput)
            const localVarPath = `/api/data-lookup/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDataLookupInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRailSensorData: async (eSDataUpdateInput: Array<ESDataUpdateInput>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eSDataUpdateInput' is not null or undefined
            assertParamExists('updateRailSensorData', 'eSDataUpdateInput', eSDataUpdateInput)
            const localVarPath = `/api/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eSDataUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDatasetFile: async (files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/data/upload-dataset-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetControllerApi - functional programming interface
 * @export
 */
export const DatasetControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allTimeStats(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllTimeESStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allTimeStats(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countRecordsDailyInLast30Days(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countRecordsDailyInLast30Days(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countRecordsMonthlyLast6Months(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countRecordsMonthlyLast6Months(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataLookup(updateDataLookupInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataLookup(lookupName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataLookup(lookupName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} wb 
         * @param {string} [trainNo] 
         * @param {string} [carNo] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [severity] 
         * @param {boolean} [hasDefectScore] 
         * @param {number} [hasDefectUser] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllConditionData(wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRailSensorData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllConditionData(wb, trainNo, carNo, fromDate, toDate, severity, hasDefectScore, hasDefectUser, page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDataLookups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataLookup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDataLookups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [trainNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarLists(trainNumber?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarLists(trainNumber, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataToPredict(page?: number, size?: number, sort?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRailSensorData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataToPredict(page, size, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainLists(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainLists(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportESDataFromFileInput} importESDataFromFileInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importESIndexFromCSV(importESDataFromFileInput: ImportESDataFromFileInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importESIndexFromCSV(importESDataFromFileInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataLookup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataLookup(updateDataLookupInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRailSensorData(eSDataUpdateInput: Array<ESDataUpdateInput>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RailSensorData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRailSensorData(eSDataUpdateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDatasetFile(files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDatasetFile(files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetControllerApi - factory interface
 * @export
 */
export const DatasetControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allTimeStats(options?: any): AxiosPromise<AllTimeESStats> {
            return localVarFp.allTimeStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsDailyInLast30Days(options?: any): AxiosPromise<Array<number>> {
            return localVarFp.countRecordsDailyInLast30Days(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRecordsMonthlyLast6Months(options?: any): AxiosPromise<Array<number>> {
            return localVarFp.countRecordsMonthlyLast6Months(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.createDataLookup(updateDataLookupInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} lookupName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataLookup(lookupName: string, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.deleteDataLookup(lookupName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} wb 
         * @param {string} [trainNo] 
         * @param {string} [carNo] 
         * @param {string} [fromDate] 
         * @param {string} [toDate] 
         * @param {number} [severity] 
         * @param {boolean} [hasDefectScore] 
         * @param {number} [hasDefectUser] 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConditionData(wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PageRailSensorData> {
            return localVarFp.getAllConditionData(wb, trainNo, carNo, fromDate, toDate, severity, hasDefectScore, hasDefectUser, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDataLookups(options?: any): AxiosPromise<Array<DataLookup>> {
            return localVarFp.getAllDataLookups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [trainNumber] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarLists(trainNumber?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getCarLists(trainNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] Zero-based page index (0..N)
         * @param {number} [size] The size of the page to be returned
         * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataToPredict(page?: number, size?: number, sort?: Array<string>, options?: any): AxiosPromise<PageRailSensorData> {
            return localVarFp.getDataToPredict(page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainLists(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTrainLists(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportESDataFromFileInput} importESDataFromFileInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importESIndexFromCSV(importESDataFromFileInput: ImportESDataFromFileInput, options?: any): AxiosPromise<void> {
            return localVarFp.importESIndexFromCSV(importESDataFromFileInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDataLookupInput} updateDataLookupInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any): AxiosPromise<DataLookup> {
            return localVarFp.updateDataLookup(updateDataLookupInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRailSensorData(eSDataUpdateInput: Array<ESDataUpdateInput>, options?: any): AxiosPromise<Array<RailSensorData>> {
            return localVarFp.updateRailSensorData(eSDataUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDatasetFile(files?: Array<any>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.uploadDatasetFile(files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetControllerApi - object-oriented interface
 * @export
 * @class DatasetControllerApi
 * @extends {BaseAPI}
 */
export class DatasetControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public allTimeStats(options?: any) {
        return DatasetControllerApiFp(this.configuration).allTimeStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public countRecordsDailyInLast30Days(options?: any) {
        return DatasetControllerApiFp(this.configuration).countRecordsDailyInLast30Days(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public countRecordsMonthlyLast6Months(options?: any) {
        return DatasetControllerApiFp(this.configuration).countRecordsMonthlyLast6Months(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDataLookupInput} updateDataLookupInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public createDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).createDataLookup(updateDataLookupInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} lookupName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public deleteDataLookup(lookupName: string, options?: any) {
        return DatasetControllerApiFp(this.configuration).deleteDataLookup(lookupName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} wb 
     * @param {string} [trainNo] 
     * @param {string} [carNo] 
     * @param {string} [fromDate] 
     * @param {string} [toDate] 
     * @param {number} [severity] 
     * @param {boolean} [hasDefectScore] 
     * @param {number} [hasDefectUser] 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getAllConditionData(wb: string, trainNo?: string, carNo?: string, fromDate?: string, toDate?: string, severity?: number, hasDefectScore?: boolean, hasDefectUser?: number, page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetControllerApiFp(this.configuration).getAllConditionData(wb, trainNo, carNo, fromDate, toDate, severity, hasDefectScore, hasDefectUser, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getAllDataLookups(options?: any) {
        return DatasetControllerApiFp(this.configuration).getAllDataLookups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [trainNumber] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getCarLists(trainNumber?: string, options?: any) {
        return DatasetControllerApiFp(this.configuration).getCarLists(trainNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getDataToPredict(page?: number, size?: number, sort?: Array<string>, options?: any) {
        return DatasetControllerApiFp(this.configuration).getDataToPredict(page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public getTrainLists(options?: any) {
        return DatasetControllerApiFp(this.configuration).getTrainLists(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportESDataFromFileInput} importESDataFromFileInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public importESIndexFromCSV(importESDataFromFileInput: ImportESDataFromFileInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).importESIndexFromCSV(importESDataFromFileInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDataLookupInput} updateDataLookupInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public updateDataLookup(updateDataLookupInput: UpdateDataLookupInput, options?: any) {
        return DatasetControllerApiFp(this.configuration).updateDataLookup(updateDataLookupInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<ESDataUpdateInput>} eSDataUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public updateRailSensorData(eSDataUpdateInput: Array<ESDataUpdateInput>, options?: any) {
        return DatasetControllerApiFp(this.configuration).updateRailSensorData(eSDataUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<any>} [files] Files to be uploaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetControllerApi
     */
    public uploadDatasetFile(files?: Array<any>, options?: any) {
        return DatasetControllerApiFp(this.configuration).uploadDatasetFile(files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatasetDatabaseControllerApi - axios parameter creator
 * @export
 */
export const DatasetDatabaseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledBearingData: async (dataType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('getUnlabeledBearingData', 'dataType', dataType)
            const localVarPath = `/api/data/database/get-all-bearing-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledEngineData: async (dataType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('getUnlabeledEngineData', 'dataType', dataType)
            const localVarPath = `/api/data/database/get-all-engine-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledGearboxData: async (dataType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('getUnlabeledGearboxData', 'dataType', dataType)
            const localVarPath = `/api/data/database/get-all-gearbox-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledTempLifeData: async (dataType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('getUnlabeledTempLifeData', 'dataType', dataType)
            const localVarPath = `/api/data/database/get-all-templife-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledWheelData: async (dataType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('getUnlabeledWheelData', 'dataType', dataType)
            const localVarPath = `/api/data/database/get-all-wheel-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateData: async (dbDataUpdateInput: Array<DbDataUpdateInput>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dbDataUpdateInput' is not null or undefined
            assertParamExists('updateData', 'dbDataUpdateInput', dbDataUpdateInput)
            const localVarPath = `/api/data/database/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dbDataUpdateInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCSVFileAndImportDB: async (partType: string, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('uploadCSVFileAndImportDB', 'partType', partType)
            const localVarPath = `/api/data/database/upload-dataset-file-to-database/{partType}`
                .replace(`{${"partType"}}`, encodeURIComponent(String(partType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetDatabaseControllerApi - functional programming interface
 * @export
 */
export const DatasetDatabaseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetDatabaseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledBearingData(dataType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorBearing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledBearingData(dataType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledEngineData(dataType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorEngine>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledEngineData(dataType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledGearboxData(dataType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorGearbox>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledGearboxData(dataType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledTempLifeData(dataType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorTempLife>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledTempLifeData(dataType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlabeledWheelData(dataType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SensorWheel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlabeledWheelData(dataType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateData(dbDataUpdateInput: Array<DbDataUpdateInput>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateData(dbDataUpdateInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCSVFileAndImportDB(partType: string, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCSVFileAndImportDB(partType, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatasetDatabaseControllerApi - factory interface
 * @export
 */
export const DatasetDatabaseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetDatabaseControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledBearingData(dataType: string, options?: any): AxiosPromise<Array<SensorBearing>> {
            return localVarFp.getUnlabeledBearingData(dataType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledEngineData(dataType: string, options?: any): AxiosPromise<Array<SensorEngine>> {
            return localVarFp.getUnlabeledEngineData(dataType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledGearboxData(dataType: string, options?: any): AxiosPromise<Array<SensorGearbox>> {
            return localVarFp.getUnlabeledGearboxData(dataType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledTempLifeData(dataType: string, options?: any): AxiosPromise<Array<SensorTempLife>> {
            return localVarFp.getUnlabeledTempLifeData(dataType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dataType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlabeledWheelData(dataType: string, options?: any): AxiosPromise<Array<SensorWheel>> {
            return localVarFp.getUnlabeledWheelData(dataType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateData(dbDataUpdateInput: Array<DbDataUpdateInput>, options?: any): AxiosPromise<string> {
            return localVarFp.updateData(dbDataUpdateInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {Array<any>} [files] Files to be uploaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCSVFileAndImportDB(partType: string, files?: Array<any>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.uploadCSVFileAndImportDB(partType, files, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetDatabaseControllerApi - object-oriented interface
 * @export
 * @class DatasetDatabaseControllerApi
 * @extends {BaseAPI}
 */
export class DatasetDatabaseControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} dataType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledBearingData(dataType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledBearingData(dataType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dataType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledEngineData(dataType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledEngineData(dataType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dataType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledGearboxData(dataType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledGearboxData(dataType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dataType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledTempLifeData(dataType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledTempLifeData(dataType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dataType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public getUnlabeledWheelData(dataType: string, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).getUnlabeledWheelData(dataType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<DbDataUpdateInput>} dbDataUpdateInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public updateData(dbDataUpdateInput: Array<DbDataUpdateInput>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).updateData(dbDataUpdateInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {Array<any>} [files] Files to be uploaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetDatabaseControllerApi
     */
    public uploadCSVFileAndImportDB(partType: string, files?: Array<any>, options?: any) {
        return DatasetDatabaseControllerApiFp(this.configuration).uploadCSVFileAndImportDB(partType, files, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverCorrectionControllerApi - axios parameter creator
 * @export
 */
export const DriverCorrectionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getBnList', 'data', data)
            const localVarPath = `/api/drivercorrection/bnList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/drivercorrection/divsList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdaList: async (data: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('getSdaList', 'data', data)
            const localVarPath = `/api/drivercorrection/sdaList/{data}`
                .replace(`{${"data"}}`, encodeURIComponent(String(data)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (searchRequest: SearchRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchRequest' is not null or undefined
            assertParamExists('search', 'searchRequest', searchRequest)
            const localVarPath = `/api/drivercorrection/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverCorrectionControllerApi - functional programming interface
 * @export
 */
export const DriverCorrectionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverCorrectionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBnList(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TreeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBnList(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDivList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDivList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdaList(data: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdaList(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(searchRequest: SearchRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(searchRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverCorrectionControllerApi - factory interface
 * @export
 */
export const DriverCorrectionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverCorrectionControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBnList(data: string, options?: any): AxiosPromise<Array<TreeInfo>> {
            return localVarFp.getBnList(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDivList(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getDivList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdaList(data: string, options?: any): AxiosPromise<Array<Sda>> {
            return localVarFp.getSdaList(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchRequest} searchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(searchRequest: SearchRequest, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.search(searchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriverCorrectionControllerApi - object-oriented interface
 * @export
 * @class DriverCorrectionControllerApi
 * @extends {BaseAPI}
 */
export class DriverCorrectionControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public getBnList(data: string, options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).getBnList(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public getDivList(options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).getDivList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public getSdaList(data: string, options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).getSdaList(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchRequest} searchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionControllerApi
     */
    public search(searchRequest: SearchRequest, options?: any) {
        return DriverCorrectionControllerApiFp(this.configuration).search(searchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DriverCorrectionSettingControllerApi - axios parameter creator
 * @export
 */
export const DriverCorrectionSettingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<DriverAttitd>} driverAttitd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial2: async (driverAttitd: Array<DriverAttitd>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'driverAttitd' is not null or undefined
            assertParamExists('createTutorial2', 'driverAttitd', driverAttitd)
            const localVarPath = `/api/driverPostureCorrection/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(driverAttitd, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSnsrList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/driverPostureCorrection/snsrlist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/driverPostureCorrection/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DriverCorrectionSettingControllerApi - functional programming interface
 * @export
 */
export const DriverCorrectionSettingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DriverCorrectionSettingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<DriverAttitd>} driverAttitd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial2(driverAttitd: Array<DriverAttitd>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DriverAttitd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial2(driverAttitd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSnsrList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Snsr>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSnsrList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholdList2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DriverAttitd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholdList2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DriverCorrectionSettingControllerApi - factory interface
 * @export
 */
export const DriverCorrectionSettingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DriverCorrectionSettingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<DriverAttitd>} driverAttitd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial2(driverAttitd: Array<DriverAttitd>, options?: any): AxiosPromise<DriverAttitd> {
            return localVarFp.createTutorial2(driverAttitd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSnsrList(options?: any): AxiosPromise<Array<Snsr>> {
            return localVarFp.findSnsrList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList2(options?: any): AxiosPromise<Array<DriverAttitd>> {
            return localVarFp.getThresholdList2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DriverCorrectionSettingControllerApi - object-oriented interface
 * @export
 * @class DriverCorrectionSettingControllerApi
 * @extends {BaseAPI}
 */
export class DriverCorrectionSettingControllerApi extends BaseAPI {
    /**
     * 
     * @param {Array<DriverAttitd>} driverAttitd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionSettingControllerApi
     */
    public createTutorial2(driverAttitd: Array<DriverAttitd>, options?: any) {
        return DriverCorrectionSettingControllerApiFp(this.configuration).createTutorial2(driverAttitd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionSettingControllerApi
     */
    public findSnsrList(options?: any) {
        return DriverCorrectionSettingControllerApiFp(this.configuration).findSnsrList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DriverCorrectionSettingControllerApi
     */
    public getThresholdList2(options?: any) {
        return DriverCorrectionSettingControllerApiFp(this.configuration).getThresholdList2(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MlControllerApi - axios parameter creator
 * @export
 */
export const MlControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chiSquareFS: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('chiSquareFS', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/fs/chi-sq`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationPredict: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('classificationPredict', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('classificationPredict', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/classification-predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel: async (algorithm: string, algorithmResponseId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('deleteModel', 'algorithm', algorithm)
            // verify required parameter 'algorithmResponseId' is not null or undefined
            assertParamExists('deleteModel', 'algorithmResponseId', algorithmResponseId)
            const localVarPath = `/api/ml/{algorithm}/model/{algorithmResponseId}`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)))
                .replace(`{${"algorithmResponseId"}}`, encodeURIComponent(String(algorithmResponseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels: async (algorithm: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('getModels', 'algorithm', algorithm)
            const localVarPath = `/api/ml/{algorithm}/models`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataColumnList: async (index: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'index' is not null or undefined
            assertParamExists('getTrainingDataColumnList', 'index', index)
            const localVarPath = `/api/get-trainingDataColumnList/{index}`
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataList: async (partType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'partType' is not null or undefined
            assertParamExists('getTrainingDataList', 'partType', partType)
            const localVarPath = `/api/get-trainingData/{partType}`
                .replace(`{${"partType"}}`, encodeURIComponent(String(partType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcaDimensionalityReduction: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('pcaDimensionalityReduction', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/fs/pca`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictCluster: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('predictCluster', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('predictCluster', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/cluster-predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regressionPredict: async (algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithmName' is not null or undefined
            assertParamExists('regressionPredict', 'algorithmName', algorithmName)
            // verify required parameter 'baseAlgorithmPredictInput' is not null or undefined
            assertParamExists('regressionPredict', 'baseAlgorithmPredictInput', baseAlgorithmPredictInput)
            const localVarPath = `/api/regression-predict/{algorithmName}`
                .replace(`{${"algorithmName"}}`, encodeURIComponent(String(algorithmName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmPredictInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainIsolationForest: async (clusterTrainInput: ClusterTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterTrainInput' is not null or undefined
            assertParamExists('trainIsolationForest', 'clusterTrainInput', clusterTrainInput)
            const localVarPath = `/api/train/if`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainKmean: async (clusterTrainInput: ClusterTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'clusterTrainInput' is not null or undefined
            assertParamExists('trainKmean', 'clusterTrainInput', clusterTrainInput)
            const localVarPath = `/api/train/kmean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLassoRegression: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLassoRegression', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/lasso`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinearRegression: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLinearRegression', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/linear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLr: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainLr', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/lr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainMLP: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainMLP', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/mlp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainRfc: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainRfc', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/rfc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainSVC: async (baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'baseAlgorithmTrainInput' is not null or undefined
            assertParamExists('trainSVC', 'baseAlgorithmTrainInput', baseAlgorithmTrainInput)
            const localVarPath = `/api/train/svc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(baseAlgorithmTrainInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel: async (algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'algorithm' is not null or undefined
            assertParamExists('updateModel', 'algorithm', algorithm)
            // verify required parameter 'algorithmResponseId' is not null or undefined
            assertParamExists('updateModel', 'algorithmResponseId', algorithmResponseId)
            // verify required parameter 'updateModelInput' is not null or undefined
            assertParamExists('updateModel', 'updateModelInput', updateModelInput)
            const localVarPath = `/api/ml/{algorithm}/model/{algorithmResponseId}`
                .replace(`{${"algorithm"}}`, encodeURIComponent(String(algorithm)))
                .replace(`{${"algorithmResponseId"}}`, encodeURIComponent(String(algorithmResponseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateModelInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MlControllerApi - functional programming interface
 * @export
 */
export const MlControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MlControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FSResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chiSquareFS(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classificationPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classificationPredict(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModel(algorithm: string, algorithmResponseId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModel(algorithm, algorithmResponseId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModels(algorithm: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DbModelResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModels(algorithm, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingDataColumnList(index: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingDataColumnList(index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrainingDataList(partType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrainingDataList(partType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FSResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcaDimensionalityReduction(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.predictCluster(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regressionPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regressionPredict(algorithmName, baseAlgorithmPredictInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainIsolationForest(clusterTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainKmean(clusterTrainInput: ClusterTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainKmean(clusterTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLassoRegression(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegressionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLinearRegression(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainLr(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainMLP(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RandomForestClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainRfc(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainSVC(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainSVC(baseAlgorithmTrainInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DbModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModel(algorithm, algorithmResponseId, updateModelInput, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MlControllerApi - factory interface
 * @export
 */
export const MlControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MlControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<FSResponse> {
            return localVarFp.chiSquareFS(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classificationPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.classificationPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModel(algorithm: string, algorithmResponseId: number, options?: any): AxiosPromise<boolean> {
            return localVarFp.deleteModel(algorithm, algorithmResponseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModels(algorithm: string, options?: any): AxiosPromise<Array<DbModelResponse>> {
            return localVarFp.getModels(algorithm, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} index 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataColumnList(index: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTrainingDataColumnList(index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} partType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrainingDataList(partType: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTrainingDataList(partType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<FSResponse> {
            return localVarFp.pcaDimensionalityReduction(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.predictCluster(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithmName 
         * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regressionPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.regressionPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.trainIsolationForest(clusterTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterTrainInput} clusterTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainKmean(clusterTrainInput: ClusterTrainInput, options?: any): AxiosPromise<ClusterResponse> {
            return localVarFp.trainKmean(clusterTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.trainLassoRegression(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RegressionResponse> {
            return localVarFp.trainLinearRegression(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainLr(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainMLP(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<RandomForestClassificationResponse> {
            return localVarFp.trainRfc(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainSVC(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any): AxiosPromise<ClassificationResponse> {
            return localVarFp.trainSVC(baseAlgorithmTrainInput, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} algorithm 
         * @param {number} algorithmResponseId 
         * @param {UpdateModelInput} updateModelInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any): AxiosPromise<DbModelResponse> {
            return localVarFp.updateModel(algorithm, algorithmResponseId, updateModelInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MlControllerApi - object-oriented interface
 * @export
 * @class MlControllerApi
 * @extends {BaseAPI}
 */
export class MlControllerApi extends BaseAPI {
    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public chiSquareFS(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).chiSquareFS(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public classificationPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).classificationPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {number} algorithmResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public deleteModel(algorithm: string, algorithmResponseId: number, options?: any) {
        return MlControllerApiFp(this.configuration).deleteModel(algorithm, algorithmResponseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getModels(algorithm: string, options?: any) {
        return MlControllerApiFp(this.configuration).getModels(algorithm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} index 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getTrainingDataColumnList(index: string, options?: any) {
        return MlControllerApiFp(this.configuration).getTrainingDataColumnList(index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} partType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public getTrainingDataList(partType: string, options?: any) {
        return MlControllerApiFp(this.configuration).getTrainingDataList(partType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public pcaDimensionalityReduction(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).pcaDimensionalityReduction(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public predictCluster(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).predictCluster(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithmName 
     * @param {BaseAlgorithmPredictInput} baseAlgorithmPredictInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public regressionPredict(algorithmName: string, baseAlgorithmPredictInput: BaseAlgorithmPredictInput, options?: any) {
        return MlControllerApiFp(this.configuration).regressionPredict(algorithmName, baseAlgorithmPredictInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClusterTrainInput} clusterTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainIsolationForest(clusterTrainInput: ClusterTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainIsolationForest(clusterTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ClusterTrainInput} clusterTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainKmean(clusterTrainInput: ClusterTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainKmean(clusterTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLassoRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLassoRegression(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLinearRegression(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLinearRegression(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainLr(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainLr(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainMLP(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainMLP(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainRfc(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainRfc(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BaseAlgorithmTrainInput} baseAlgorithmTrainInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public trainSVC(baseAlgorithmTrainInput: BaseAlgorithmTrainInput, options?: any) {
        return MlControllerApiFp(this.configuration).trainSVC(baseAlgorithmTrainInput, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} algorithm 
     * @param {number} algorithmResponseId 
     * @param {UpdateModelInput} updateModelInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MlControllerApi
     */
    public updateModel(algorithm: string, algorithmResponseId: number, updateModelInput: UpdateModelInput, options?: any) {
        return MlControllerApiFp(this.configuration).updateModel(algorithm, algorithmResponseId, updateModelInput, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PartsReplacementCycleSettingControllerApi - axios parameter creator
 * @export
 */
export const PartsReplacementCycleSettingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<Cmpntsrplc>} cmpntsrplc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial1: async (cmpntsrplc: Array<Cmpntsrplc>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cmpntsrplc' is not null or undefined
            assertParamExists('createTutorial1', 'cmpntsrplc', cmpntsrplc)
            const localVarPath = `/api/partsreplacementcycle/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmpntsrplc, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/partsreplacementcycle/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartsReplacementCycleSettingControllerApi - functional programming interface
 * @export
 */
export const PartsReplacementCycleSettingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PartsReplacementCycleSettingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<Cmpntsrplc>} cmpntsrplc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial1(cmpntsrplc: Array<Cmpntsrplc>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmpntsrplc>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial1(cmpntsrplc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholdList1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CmpntsrplcResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholdList1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PartsReplacementCycleSettingControllerApi - factory interface
 * @export
 */
export const PartsReplacementCycleSettingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PartsReplacementCycleSettingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<Cmpntsrplc>} cmpntsrplc 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial1(cmpntsrplc: Array<Cmpntsrplc>, options?: any): AxiosPromise<Cmpntsrplc> {
            return localVarFp.createTutorial1(cmpntsrplc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList1(options?: any): AxiosPromise<Array<CmpntsrplcResponse>> {
            return localVarFp.getThresholdList1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PartsReplacementCycleSettingControllerApi - object-oriented interface
 * @export
 * @class PartsReplacementCycleSettingControllerApi
 * @extends {BaseAPI}
 */
export class PartsReplacementCycleSettingControllerApi extends BaseAPI {
    /**
     * 
     * @param {Array<Cmpntsrplc>} cmpntsrplc 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public createTutorial1(cmpntsrplc: Array<Cmpntsrplc>, options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).createTutorial1(cmpntsrplc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartsReplacementCycleSettingControllerApi
     */
    public getThresholdList1(options?: any) {
        return PartsReplacementCycleSettingControllerApiFp(this.configuration).getThresholdList1(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatisticalInfoControllerApi - axios parameter creator
 * @export
 */
export const StatisticalInfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraph: async (statisticalInfo: StatisticalInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'statisticalInfo' is not null or undefined
            assertParamExists('getGraph', 'statisticalInfo', statisticalInfo)
            const localVarPath = `/api/statistical/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticalInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/statistical/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable: async (statisticalInfo: StatisticalInfo, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'statisticalInfo' is not null or undefined
            assertParamExists('getTable', 'statisticalInfo', statisticalInfo)
            const localVarPath = `/api/statistical/table`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(statisticalInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticalInfoControllerApi - functional programming interface
 * @export
 */
export const StatisticalInfoControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticalInfoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGraph(statisticalInfo: StatisticalInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGraph(statisticalInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTable(statisticalInfo: StatisticalInfo, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTable(statisticalInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatisticalInfoControllerApi - factory interface
 * @export
 */
export const StatisticalInfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticalInfoControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGraph(statisticalInfo: StatisticalInfo, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getGraph(statisticalInfo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StatisticalInfo} statisticalInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTable(statisticalInfo: StatisticalInfo, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getTable(statisticalInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatisticalInfoControllerApi - object-oriented interface
 * @export
 * @class StatisticalInfoControllerApi
 * @extends {BaseAPI}
 */
export class StatisticalInfoControllerApi extends BaseAPI {
    /**
     * 
     * @param {StatisticalInfo} statisticalInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getGraph(statisticalInfo: StatisticalInfo, options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getGraph(statisticalInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getInfo(options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StatisticalInfo} statisticalInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticalInfoControllerApi
     */
    public getTable(statisticalInfo: StatisticalInfo, options?: any) {
        return StatisticalInfoControllerApiFp(this.configuration).getTable(statisticalInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderatorAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/mod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccess: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/test/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moderatorAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moderatorAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccess(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccess(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAccess(options?: any): AxiosPromise<string> {
            return localVarFp.adminAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allAccess(options?: any): AxiosPromise<string> {
            return localVarFp.allAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moderatorAccess(options?: any): AxiosPromise<string> {
            return localVarFp.moderatorAccess(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccess(options?: any): AxiosPromise<string> {
            return localVarFp.userAccess(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public adminAccess(options?: any) {
        return TestControllerApiFp(this.configuration).adminAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public allAccess(options?: any) {
        return TestControllerApiFp(this.configuration).allAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public moderatorAccess(options?: any) {
        return TestControllerApiFp(this.configuration).moderatorAccess(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public userAccess(options?: any) {
        return TestControllerApiFp(this.configuration).userAccess(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ThresholdControllerApi - axios parameter creator
 * @export
 */
export const ThresholdControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<ThresholdResponse>} thresholdResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial: async (thresholdResponse: Array<ThresholdResponse>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'thresholdResponse' is not null or undefined
            assertParamExists('createTutorial', 'thresholdResponse', thresholdResponse)
            const localVarPath = `/api/threshold/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(thresholdResponse, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList: async (title?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/threshold/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ThresholdControllerApi - functional programming interface
 * @export
 */
export const ThresholdControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ThresholdControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<ThresholdResponse>} thresholdResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTutorial(thresholdResponse: Array<ThresholdResponse>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Threshold>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTutorial(thresholdResponse, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getThresholdList(title?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ThresholdResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getThresholdList(title, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ThresholdControllerApi - factory interface
 * @export
 */
export const ThresholdControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ThresholdControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<ThresholdResponse>} thresholdResponse 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTutorial(thresholdResponse: Array<ThresholdResponse>, options?: any): AxiosPromise<Threshold> {
            return localVarFp.createTutorial(thresholdResponse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [title] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getThresholdList(title?: string, options?: any): AxiosPromise<Array<ThresholdResponse>> {
            return localVarFp.getThresholdList(title, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ThresholdControllerApi - object-oriented interface
 * @export
 * @class ThresholdControllerApi
 * @extends {BaseAPI}
 */
export class ThresholdControllerApi extends BaseAPI {
    /**
     * 
     * @param {Array<ThresholdResponse>} thresholdResponse 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThresholdControllerApi
     */
    public createTutorial(thresholdResponse: Array<ThresholdResponse>, options?: any) {
        return ThresholdControllerApiFp(this.configuration).createTutorial(thresholdResponse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [title] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ThresholdControllerApi
     */
    public getThresholdList(title?: string, options?: any) {
        return ThresholdControllerApiFp(this.configuration).getThresholdList(title, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserManagementControllerApi - axios parameter creator
 * @export
 */
export const UserManagementControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/api/user/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/api/user/info/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/api/user/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementControllerApi - functional programming interface
 * @export
 */
export const UserManagementControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmncd>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmncdList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmncdList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserManagementControllerApi - factory interface
 * @export
 */
export const UserManagementControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<Cmncd> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmncdList(page?: number, pageSize?: number, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getCmncdList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementControllerApi - object-oriented interface
 * @export
 * @class UserManagementControllerApi
 * @extends {BaseAPI}
 */
export class UserManagementControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public deleteUser(id: string, options?: any) {
        return UserManagementControllerApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public getCmncdList(page?: number, pageSize?: number, options?: any) {
        return UserManagementControllerApiFp(this.configuration).getCmncdList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public getUser(id: string, options?: any) {
        return UserManagementControllerApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementControllerApi
     */
    public updateUser(user: User, options?: any) {
        return UserManagementControllerApiFp(this.configuration).updateUser(user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VehicleStatisticsControllerApi - axios parameter creator
 * @export
 */
export const VehicleStatisticsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultBookmark: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('defaultBookmark', 'id', id)
            const localVarPath = `/api/vehicleStatistics/allBookmarkForDefault/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sdaid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRecentFile: async (sdaid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sdaid' is not null or undefined
            assertParamExists('findRecentFile', 'sdaid', sdaid)
            const localVarPath = `/api/vehicleStatistics/findRecentFile/{sdaid}`
                .replace(`{${"sdaid"}}`, encodeURIComponent(String(sdaid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicleData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} grpid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark: async (id: string, grpid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBookmark', 'id', id)
            // verify required parameter 'grpid' is not null or undefined
            assertParamExists('getBookmark', 'grpid', grpid)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getBookmark/{id}/{grpid}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"grpid"}}`, encodeURIComponent(String(grpid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<object>} param1 
         * @param {Array<object>} param2 
         * @param {Array<object>} param3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartData: async (param1: Array<object>, param2: Array<object>, param3: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'param1' is not null or undefined
            assertParamExists('getChartData', 'param1', param1)
            // verify required parameter 'param2' is not null or undefined
            assertParamExists('getChartData', 'param2', param2)
            // verify required parameter 'param3' is not null or undefined
            assertParamExists('getChartData', 'param3', param3)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getChartData/{param1}/{param2}/{param3}`
                .replace(`{${"param1"}}`, encodeURIComponent(String(param1)))
                .replace(`{${"param2"}}`, encodeURIComponent(String(param2)))
                .replace(`{${"param3"}}`, encodeURIComponent(String(param3)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<object>} params1 
         * @param {Array<object>} params2 
         * @param {Array<object>} params3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDtctsdaData: async (params1: Array<object>, params2: Array<object>, params3: Array<object>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'params1' is not null or undefined
            assertParamExists('getDtctsdaData', 'params1', params1)
            // verify required parameter 'params2' is not null or undefined
            assertParamExists('getDtctsdaData', 'params2', params2)
            // verify required parameter 'params3' is not null or undefined
            assertParamExists('getDtctsdaData', 'params3', params3)
            const localVarPath = `/api/vehicleStatistics/getDtctsdaData/{params1}/{params2}/{params3}`
                .replace(`{${"params1"}}`, encodeURIComponent(String(params1)))
                .replace(`{${"params2"}}`, encodeURIComponent(String(params2)))
                .replace(`{${"params3"}}`, encodeURIComponent(String(params3)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEachData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEachData', 'id', id)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileWithId: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFileWithId', 'id', id)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getFile/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton1: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getForBtn1`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/getForBtn2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<UserSnsr>} userSnsr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertBookmark: async (userSnsr: Array<UserSnsr>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSnsr' is not null or undefined
            assertParamExists('insertBookmark', 'userSnsr', userSnsr)
            const localVarPath = `/api/vehicleStatistics/searchEachInfo/insertBookmarks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer-key required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSnsr, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehicleStatisticsControllerApi - functional programming interface
 * @export
 */
export const VehicleStatisticsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VehicleStatisticsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultBookmark(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultBookmark(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sdaid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRecentFile(sdaid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRecentFile(sdaid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllVehicleData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVehicleData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} grpid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBookmark(id: string, grpid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSnsr>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBookmark(id, grpid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<object>} param1 
         * @param {Array<object>} param2 
         * @param {Array<object>} param3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChartData(param1: Array<object>, param2: Array<object>, param3: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SdaData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChartData(param1, param2, param3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<object>} params1 
         * @param {Array<object>} params2 
         * @param {Array<object>} params3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDtctsdaData(params1: Array<object>, params2: Array<object>, params3: Array<object>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SdaDataWithDtctsda>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDtctsdaData(params1, params2, params3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEachData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sda>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEachData(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileWithId(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SdaData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileWithId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForButton1(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForButton1(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForButton2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmncd>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForButton2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<UserSnsr>} userSnsr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertBookmark(userSnsr: Array<UserSnsr>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSnsr>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertBookmark(userSnsr, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VehicleStatisticsControllerApi - factory interface
 * @export
 */
export const VehicleStatisticsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VehicleStatisticsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultBookmark(id: string, options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.defaultBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sdaid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRecentFile(sdaid: string, options?: any): AxiosPromise<string> {
            return localVarFp.findRecentFile(sdaid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllVehicleData(options?: any): AxiosPromise<Array<Sda>> {
            return localVarFp.getAllVehicleData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} grpid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookmark(id: string, grpid: string, options?: any): AxiosPromise<Array<UserSnsr>> {
            return localVarFp.getBookmark(id, grpid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<object>} param1 
         * @param {Array<object>} param2 
         * @param {Array<object>} param3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChartData(param1: Array<object>, param2: Array<object>, param3: Array<object>, options?: any): AxiosPromise<Array<SdaData>> {
            return localVarFp.getChartData(param1, param2, param3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<object>} params1 
         * @param {Array<object>} params2 
         * @param {Array<object>} params3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDtctsdaData(params1: Array<object>, params2: Array<object>, params3: Array<object>, options?: any): AxiosPromise<Array<SdaDataWithDtctsda>> {
            return localVarFp.getDtctsdaData(params1, params2, params3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEachData(id: string, options?: any): AxiosPromise<Sda> {
            return localVarFp.getEachData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileWithId(id: string, options?: any): AxiosPromise<Array<SdaData>> {
            return localVarFp.getFileWithId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton1(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getForButton1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForButton2(options?: any): AxiosPromise<Array<Cmncd>> {
            return localVarFp.getForButton2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<UserSnsr>} userSnsr 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertBookmark(userSnsr: Array<UserSnsr>, options?: any): AxiosPromise<UserSnsr> {
            return localVarFp.insertBookmark(userSnsr, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VehicleStatisticsControllerApi - object-oriented interface
 * @export
 * @class VehicleStatisticsControllerApi
 * @extends {BaseAPI}
 */
export class VehicleStatisticsControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public defaultBookmark(id: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).defaultBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sdaid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public findRecentFile(sdaid: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).findRecentFile(sdaid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getAllVehicleData(options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getAllVehicleData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} grpid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getBookmark(id: string, grpid: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getBookmark(id, grpid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<object>} param1 
     * @param {Array<object>} param2 
     * @param {Array<object>} param3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getChartData(param1: Array<object>, param2: Array<object>, param3: Array<object>, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getChartData(param1, param2, param3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<object>} params1 
     * @param {Array<object>} params2 
     * @param {Array<object>} params3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getDtctsdaData(params1: Array<object>, params2: Array<object>, params3: Array<object>, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getDtctsdaData(params1, params2, params3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getEachData(id: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getEachData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getFileWithId(id: string, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getFileWithId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getForButton1(options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getForButton1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public getForButton2(options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).getForButton2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<UserSnsr>} userSnsr 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehicleStatisticsControllerApi
     */
    public insertBookmark(userSnsr: Array<UserSnsr>, options?: any) {
        return VehicleStatisticsControllerApiFp(this.configuration).insertBookmark(userSnsr, options).then((request) => request(this.axios, this.basePath));
    }
}


